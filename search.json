[{"title":"vue3数据双向绑定原理","url":"/posts/fe0b65a8.html","content":"// 因为vue3中不再是将数据定义到data中就可以实现响应式,而是使用reactive或ref// WeakMap 的 key 只能是 Object 类型。let targetMap = WeakMap();let activeEffect;/** * &#123; *    target:&#123; *      key: [ReactiveEffect,ReactiveEffect,....] *    &#125; * &#125; */// 收集依赖function track(target, key) &#123;    // 判断该值是否收集,未收集就添加    let depsMap = targetMap.get(target);    if (!depsMap) targetMap.set(depsMap, (depsMap = new Map()));    // 判断depsMap 中有没有key    let dep = depsMap.get(key);    if (!dep) depsMap.set(key, (dep = new Set()));    trackEffect(dep);&#125;//function trackEffect(dep) &#123;    // 相当于 vue2中的, Dep.target &amp;&amp; dep.add(Dep.target)    if (dep.has(activeEffect)) dep.add(activeEffect)&#125;// 触发function trigger(target, key) &#123;    const depsMap = targetMap.get(target);    if (!depsMap) return;    // effect 上面肯定有一个 run 方法。    depsMap.get(key).forEach(effect =&gt; effect &amp;&amp; effect.run())&#125;/** 备注1: ReflectReflect是一个内建的对象，用来提供方法去拦截JavaScript的操作。Reflect不是一个函数对象，所以它是不可构造的，也就是说它不是一个构造器，你不能通过`new`操作符去新建或者将其作为一个函数去调用Reflect对象。Reflect的所有属性和方法都是静态的。1.现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。2.修改某些Object方法的返回结果，让其变得更规范化。如Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。让Object操作都变成函数行为。3.Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。*///进行判断是否是对象function isObject(data) &#123;    return data &amp;&amp; typeof data === &#x27;object&#x27;&#125;export function reactive(data) &#123;    if (!isObject(data)) return;    // Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。    // https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-proxy.md  Proxy 支持的拦截操作，一共 13 种    // 简化createReactiveObject    return new Proxy(data, &#123;        // Reflect.get()方法与从 对象 (target[propertyKey]) 中读取属性类似，但它是通过一个函数执行来操作的。        // 因备注1.1,在继承可能会出现问题 因此这里不使用target[key]        get(target, key, reactiver) &#123;            const ret = Reflect.get(target, key, reactiver);            track(target, key);            return isObject(ret) ? reactive(ret) : ret;        &#125;,        // Reflect.set() 工作方式就像在一个对象上设置一个属性。        set(target, key, value, reactiver) &#123;            Reflect.set(target, key, value, reactiver);            trigger(target, key);            return true;        &#125;,        // 拦截delete操作，如果这个方法抛出错误，或者返回false，则当前属性就无法被delete命令删除        deleteProperty(target, key) &#123;            trigger(target, key);            return Reflect.defineProperty(target, key);        &#125;,        //拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效，典型的就是in操作符        //如果原对象不可配置或者禁止扩展，这时has拦截会报错。        //值得注意的是，has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。        has(target, key) &#123;            track(target, key);            return Reflect.has(target, key);        &#125;,        //拦截对象自身属性的读取操作，具体拦截以下操作：object.getOwnPropertyNames(), object.getOwnPropertySymbols(), object.keys()        ownKeys(target, key) &#123;            track(target, key);            return Reflect.ownKeys(target, key)        &#125;    &#125;)&#125;export function ref(init) &#123;    class RefImpl &#123;        constructor(init) &#123;            this.__value = init;        &#125;        get value() &#123;            // trackRefValue源码方法,为了方便现全部使用track            track(this, &quot;value&quot;);            return this.__value;        &#125;        set value(newValue) &#123;            this.__value = newValue;            trigger(this, &#x27;value&#x27;);        &#125;    &#125;    return new RefImpl(init)&#125;// 在定义一个 effect 的函数中，第一个参数是一个函数；// 如果这个函数中，有使用 ref/reactive // effect(() =&gt; &#123;//    console.log(num.value)// &#125;)function effect(fn, options = &#123;&#125;) &#123;    let __effect = new ReactiveEffect(fn);    if (!options.lazy) &#123;        __effect.run();    &#125;    return __effect;&#125;// 计算属性监听export function computed(fn) &#123;    // 只考虑函数的情况    let __computed;    const e = effect(fn, &#123; lazy: true &#125;);    __computed = &#123;        get value() &#123;            return e.run();        &#125;    &#125;    return __computed;&#125;export function mount(instance, el) &#123;    effect(function () &#123;        instance.$data &amp;&amp; update(instance, el);    &#125;)    instance.$data = instance.setup()    update(instance, el);    function update(instance, el) &#123;        el.innerHTML = instance.render();    &#125;&#125;class ReactiveEffect &#123;    constructor(fn) &#123;        this.fn = fn;    &#125;    run() &#123;        activeEffect = this;        return this.fn();    &#125;&#125;\n设计大纲\nProxy捕获器\n","categories":[],"tags":[]},{"title":"vue2数据双向绑定原理","url":"/posts/5b80f5a6.html","content":"// vue2中会对数据在初始化事使用的是Object.defineProperty，遍历对象将对象的每一个属性进行劫持。// vue2响应式弊端：// 响应化过程需要递归遍历，消耗较大 // 新加或删除属性无法监听// 数组响应化需要额外实现 // Map、Set、Class等无法响应式 // 修改语法有限制export function Vue(options = &#123;&#125;) &#123;  this.__init(options);&#125;Vue.prototype.__init = function (options) &#123;  this.$options = options;  // 假设这里就是一个 el， 已经 querySelector 的  this.$el = options.el;  this.$data = options.data;  this.$methods = options.methods;  proxy(this, this.$data);  observer(this.$data);  new Compiler(this);&#125;// 将this.$data改变成thisfunction proxy(target, data) &#123;  Object.keys(data).forEach(key =&gt; &#123;    Object.defineProperty(target, key, &#123;      enumerable: true,      configurable: true,      get() &#123;        return data[key];      &#125;,      set(newVal) &#123;        // 考虑 NaN 的情况        if (!isSameVal(data[key], newVal)) &#123;          data[key] = newVal;        &#125;      &#125;    &#125;)  &#125;)&#125;// Observer来监听自己的model数据变化function observer(data) &#123; new Observer(data) &#125;;class Observer &#123;  constructor(data) &#123;    this.walk(data);  &#125;  walk(data) &#123;    if (data &amp;&amp; typeof data === &quot;object&quot;) &#123;      Object.keys(data).forEach(key =&gt; this.defineReactive(data, key, data[key]));    &#125;  &#125;  // 把每一个 data 里面的数据，收集起来。  defineReactive(obj, key, value) &#123;    let that = this;    this.walk(value);    let dep = new Dep();    // Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。    // Object.defineProperty(obj, prop, descriptor)    // obj 要定义属性的对象。prop 要定义或修改的属性的名称或 Symbol。descriptor 要定义或修改的属性描述符。    Object.defineProperty(obj, key, &#123;      configurable: true,      enumerable: true,      get() &#123;        // 4. 对于 num 来说，要执行这一句。        // 5. num 中的 dep, 就有了这个 watcher        // dep: [watcher, watcher ]        Dep.target &amp;&amp; dep.add(Dep.target);        return value      &#125;,      set(newVal) &#123;        if (!isSameVal(value, newVal)) &#123;          // 赋值进来的新值，是没有响应式的，所以再 walk 一次，给到响应式。          value = newVal;          that.walk(newVal);          // 重新set时，通知更新          // 6.          dep.notify();        &#125;      &#125;    &#125;)  &#125;&#125;// 数据改变，视图才会更新。需要去观察// 1. new Watcher( vm, &#x27;num&#x27;, () =&gt; &#123;更新视图上的num显示&#125; )class Watcher &#123;  constructor(vm, key, cb) &#123;    this.vm = vm; // VUE 的一个实例    this.key = key;    this.cb = cb;        // 2. 此时 Dep.target 作为一个全局变量理解，放的就是这个 watcher;    Dep.target = this;    // 3. 一旦进行了这一句赋值，是不是就触发了这个值的 getter 函数。    this.__old = vm[key];    // 把 Dep.target 删除。    Dep.target = null;  &#125;    // 8. 执行所有的 cb 函数。  update() &#123;    let newVal = this.vm[this.key];    if (!isSameVal(newVal, this.__old)) this.cb(newVal);  &#125;&#125;// 每一个数据都要有一个 dep 的依赖class Dep &#123;  constructor() &#123;    this.watchers = new Set();  &#125;    add(watcher) &#123;    if (watcher &amp;&amp; watcher.update) this.watchers.add(watcher);  &#125;    // 7. 让所有的 watcher 执行 update 方法。  notify() &#123;    this.watchers.forEach(watc =&gt; watc.update())  &#125;&#125;// 解析器 用于解析所有标签的节点对里面的vue的指令进行解析 详细可以看vue项目中的compiler文件夹// 最终利用`Watcher`搭起`Observer`和`Compile`之间的通信桥梁class Compiler &#123;  constructor(vm) &#123;    this.el = vm.$el;    this.vm = vm;    this.methods = vm.$methods;        this.compile(vm.$el);  &#125;  // 这里是递归编译 #app 下面的所有的节点内容；  compile(el) &#123;    let childNodes = el.childNodes;    // 类数组    Array.from(childNodes).forEach(node =&gt; &#123;      // 判断如果是文本节点      if (node.nodeType === 3) &#123;        this.compileText(node)      &#125;      // 如果是元素节点      else if (node.nodeType === 1) &#123;        this.compileElement(node)      &#125;      // 如果还有子节点，就递归下去。      if (node.childNodes &amp;&amp; node.childNodes.length) this.compile(node);      // ...    &#125;)  &#125;    compileText(node) &#123;    // 匹配出来 &#123;&#123;massage&#125;&#125;    let reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/;    let value = node.textContent;    if (reg.test(value)) &#123;      let key = RegExp.$1.trim()      // 开始时赋值。      node.textContent = value.replace(reg, this.vm[key]);      // 添加观察者      new Watcher(this.vm, key, val =&gt; &#123;        // 数据改变时的更新        node.textContent = val;      &#125;)    &#125;  &#125;    compileElement(node) &#123;    // 简化，只做匹配 v-on 和 v-model 的匹配    if (node.attributes.length) &#123;      Array.from(node.attributes).forEach(attr =&gt; &#123;        let attrName = attr.name;        if (attrName.startsWith(&#x27;v-&#x27;)) &#123;          // v- 指令匹配成功，可能是 v-on:click 或者 v-model          attrName = attrName.indexOf(&#x27;:&#x27;) &gt; -1 ? attrName.substr(5) : attrName.substr(2)          let key = attr.value;          //           this.update(node, key, attrName, this.vm[key])        &#125;      &#125;)    &#125;  &#125;    update(node, key, attrName, value) &#123;    if (attrName === &#x27;model&#x27;) &#123;      node.value = value;      new Watcher(this.vm, key, val =&gt; node.value = val);      node.addEventListener(&#x27;input&#x27;, () =&gt; &#123;        this.vm[key] = node.value;      &#125;)    &#125; else if (attrName === &#x27;click&#x27;) &#123;      node.addEventListener(attrName, this.methods[key].bind(this.vm))    &#125;  &#125;&#125;function isSameVal(a, b) &#123;  return a === b || (Number.isNaN(a) &amp;&amp; Number.isNaN(b))&#125;\n\n","categories":[],"tags":[]},{"title":"发布—订阅模式","url":"/posts/85d98369.html","content":"定义发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。\n优点第一点说明发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。 比如，我们可以订阅 ajax 请求的 error、succ 等事件。或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。第二点说明发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调 用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼 此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。\nJavaScript中的运用JavaScript 本身也是一门基于事件驱动的语言，所以发布—订阅模式的运用相当广泛，如在DOM上绑定事件就是对这种模式的运用，我们只需要将事件绑定到对应DOM上后，我们将不需要关注用户何时去触发，而是关注触发后的动作。在事件触发后就DOM将会通知执行我们绑定的事件。我们常用的vue框架也是使用该模式实现了对数据的双向绑定，在使用JavaScript逻辑对需要监听的数据进行改变时，会触发改变页面显示的解析方法，同理，在页面上对监听的数据进行改变是也会去改变对应的JavaScript里的变量值，详细分析点击vue2中对发布-订阅模式的运用 和 vue3中对发布-订阅模式的运用。\n必须先订阅再发布吗？上面说到该模式广泛应用于异步编程中，对于异步里无法判断触发时间，因此会出现还未加载执行完毕订阅相关代码时发布代码执行了，造成发布消息的代码成为无效代码。对于这种情况必须编写该模块时进行判断。如创建一个存储离线事件的堆栈，当事件发布的时候，如果此时还 没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将被 存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。\n// 对于自定义对象，实现发布-订阅模式let Event = (function () &#123;    let Event = null;    let _default = &#x27;default&#x27;;    Event = function () &#123;        let _listen = null;        let _trigger = null;        let _remove = null;        let _shift = Array.prototype.shift;        let _unshift = Array.prototype.unshift;        let namespaceCache = &#123;&#125;; // 使用该对象将命名空间缓存起来        let _create = null;        // 用户当用户触发是进行事件遍历,而进行对以订阅者进行发布发布        each = function (ary, fn) &#123;            let ret = null;            for (let i = 0; i &lt; ary.length; i++) &#123;                let n = ary[i];                ret = fn.call(n, i, n);            &#125;            return ret;        &#125;;        // 添加监听        _listen = function (key, fn, cache) &#123;            console.log(cache,&quot;输出cache&quot;)            if (!cache[key]) cache[key] = [];            cache[key].push(fn);        &#125;;        // 触发        _trigger = function () &#123;            console.log(&#123;...arguments&#125;,&#x27;argumentsargumentsarguments&#x27;)            let cache = _shift.call(arguments);            console.log(cache,&#x27;cachecachecachecache&#x27;)            let key = _shift.call(arguments);            let args = arguments;            let _self = this;            let stack = cache[key];            if (!stack || !stack.length) &#123;                return;            &#125;            return each(stack, function () &#123;                return this.apply(_self, args)            &#125;)        &#125;;        // 如果已经创建该命名空间则返回该命名空间的发布订阅对象,否则将使用ret创建的新对象        _create = function (namespace) &#123;            var namespace = namespace || _default;            let cache = &#123;&#125;;            let offlineStack = [];            let ret = &#123;                listen: function (key, fn, last) &#123;                    _listen(key, fn, cache);                    if (offlineStack === null) &#123;                        return;                    &#125;                    if (last === &quot;last&quot;) &#123;                        offlineStack.length &amp;&amp; offlineStack.pop();                    &#125; else &#123;                        each(offlineStack, function () &#123;                            console.log(this)                            this();                        &#125;);                    &#125;                    offlineStack = null;                &#125;,                one: function (key, fn, last) &#123;                    _remove(key, cache);                    this.listen(key, fn, last);                &#125;,                remove: function (key, fn) &#123;                    _remove(key, cache, fn);                &#125;,                trigger: function () &#123;                    let fn = null;                    let args = arguments;                    let _self = this;                    _unshift.call(arguments, cache);                    args = arguments;                    fn = function () &#123;                        return _trigger.apply(_self, args);                    &#125;;                    if (offlineStack) &#123;                        return offlineStack.push(fn);                    &#125;                    return fn()                &#125;            &#125;;            // 如果命名空间在缓存中,则使用已经存起来的对象,如果不存在则使用_default的命名空间            return namespaceCache[namespace] ? namespaceCache[namespace] : namespaceCache[namespace] = ret;        &#125;;        return &#123;            create: _create, // 使用命名空间形式            one: function (key, fn, last) &#123;                let event = this.create();                event.one(key, fn, last);            &#125;,            remove: function (key, fn) &#123;                let event = this.create();                event.remove(key, fn);            &#125;,            listen: function (key, fn, last) &#123;                let event = this.create();                event.listen(key, fn, last)            &#125;,            trigger: function () &#123;                let event = this.create();                event.trigger.apply(this, arguments)            &#125;        &#125;    &#125;();    return Event;&#125;)();// 如果命名空间在缓存中,则使用已经存起来的对象,如果不存在则使用_default的命名空间Event.trigger(&#x27;click&#x27;, 1);Event.listen(&#x27;click&#x27;, function (a) &#123;    console.log(a);&#125;)Event.listen(&#x27;click&#x27;, function (a) &#123;    console.log(a);&#125;)// 使用命名空间=================================Event.create(&#x27;namespace1&#x27;).listen(&#x27;click&#x27;, function (a) &#123;    console.log(a);  // 输出:1&#125;);Event.create(&#x27;namespace1&#x27;).listen(&#x27;click&#x27;, function (a) &#123;    console.log(a,&#x27;大萨达萨达&#x27;);  // 输出:1&#125;);Event.create(&#x27;namespace1&#x27;).listen(&#x27;click&#x27;, function (a) &#123;    console.log(a,&#x27;禅道上的就后端数据肯定会&#x27;);  // 输出:1&#125;);Event.create(&#x27;namespace2&#x27;).listen(&#x27;click&#x27;, function (a) &#123;    console.log(a);  // 输出:2&#125;);Event.create(&#x27;namespace1&#x27;).trigger(&#x27;click&#x27;, 123);\n小结发布—订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常 广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。但是不能过度使用该模式，因此在创建后，订阅模式代码肯定会占用一定内存，不论是否有消息进行发布。而且该模式会弱化对象之间的关系，将会使代码可读性降低，进而导致程序难以跟踪维护和理解。\n","categories":[],"tags":[]},{"title":"工作技巧","url":"/posts/a6eed33.html","content":"减少嵌套 if…else 或 switch case，简单地使用基本的逻辑运算符AND&#x2F;OR。// 与 if (foo == 10) then console.log(&#x27;进入判断了&#x27;) 相同 // 输出: 进入判断了 let foo = 10; foo === 10 &amp;&amp; console.log(&#x27;进入判断了&#x27;)  // 与 if (foo != 5) then console.log(&#x27;进入判断了&#x27;) 相同 // 输出: 进入判断了foo === 5 || console.log(&#x27;进入判断了&#x27;) \nRest（剩余） &amp; Spread （扩展）运算符(…的两种意义)//示例1  方法结构传参function spread(arg1, arg2, arg3) &#123;    console.log(arg1);    console.log(arg2);    console.log(arg3);&#125;var arr = [1, 2, 3];spread(...arr);//示例2  合并数组或者对象var arr1 = [1, 2, 3, 4];var arr2 = [...arr1, 4, 5, 6];var obj1 = &#123; a: 1, b: 2, c: 3 &#125;;var obj2 = &#123; ...obj1, d: 4, e: 5, f: 6 &#125;;console.log(arr2);\n// 示例1 当函数参数个数不确定时function rest1(...arr) &#123;    for (let item of arr) &#123;        console.log(item);    &#125;&#125;rest1(1,2,3,4);//示例2 当确定其中几个,后续未知function rest2(item, ...arr) &#123;    console.log(item);    console.log(arr);&#125;rest2(1,2,3,4);//示例3 rest运算符配合 解构使用：var [a, ...temp] = [1,2,3,4];console.log(a);console.log(temp);\n开发技巧尽量在开发中面向接口开发，而不是为了任务去拼凑代码从而将代码开发成了面向实现开发。\n自定义边框虚线// 一条直的虚线background-image: linear-gradient(to bottom, #3A75FF 0%, #3A75FF 80%, transparent 50%);background-size: 3px 18px;background-repeat: y-repeat;// 边框虚线background: linear-gradient(90deg, #3A75FF 50%, transparent 0) repeat-x, linear-gradient(90deg, #3A75FF 50%, transparent 0) repeat-x, linear-gradient(0deg, #3A75FF 50%, transparent 0) repeat-y, linear-gradient(0deg, #3A75FF 50%, transparent 0) repeat-y;background-size: 8px 2px, 8px 2px, 2px 8px, 2px 8px;background-position: 0 0, 0 100%, 0 0, 100% 0;\n项目整体置灰为应对各种哀悼日将项目整体置灰\nbody,html&#123;  filter: progid:DXImageTransform.Microsoft.BasicImage(graysale=1); //针对IE浏览器   -webkit-filter: grayscale(100%);&#125;\nvideo部分浏览器出现边框问题对边框进行设置mask-image\n","categories":[],"tags":[]},{"title":"Mac搭建Flutter环境","url":"/posts/662afcd5.html","content":"安装Flutter学习网站：Flutter安装文档\n安装Flutter SDK（全程以Mac为例）这里有两种方式进行安装，分别是使用安装包和使用git进行操作:::info方法一Flutter版本列表在这里选择合适的版本进行下载下载完成后解压并方式二找到自己准备存放Flutter的文件夹 并按照如下操作:::\n// 开始下载$ git clone https://github.com/flutter/flutter.git -b stable\n// 查询自己默认使用的哪个shell$ echo $SHELL// bash$ vim ~/.bash_profile// zsh$ vim ~/.zshrc// 添加镜像$ export PUB_HOSTED_URL=https://mirrors.tuna.tsinghua.edu.cn/dart-pub$ export FLUTTER_STORAGE_BASE_URL=https://mirrors.tuna.tsinghua.edu.cn/flutter$ export FLUTTER=~/xxx // 自己文件位置 $ export PATH=$FLUTTER/bin:$PATH// 退出编辑 ⇧+q 并输入 wq！// 重载命令// bash$ source ~/.bash_profile// zsh$ source ~/.zshrc// flutter doctor命令来查看当前环境是否需要安装其他的依赖 全部都出现对钩就表明检查通过$ flutter doctor\n检查时出现的问题\nAndroid Studio (not installed)因为Flutter需要依赖Android Studio来为提供Android平台的支持，因此需要安装全量安装Android Studio，Android Studio安装地址，\nAndroid toolchain - develop for Android devices —–[X]Unable to locate Android SDK.\n\nInstall Android Studio from:https://developer.android.com/studio/index.htmlOn first launch it will assist you in installing the Android SDKcomponents.(or visit https://flutter.dev/docs/get-started/install/macos#android-setupfor detailed instructions).If the Android SDK has been installed to a custom location, please useflutter config --android-sdk to update to that location.打开下载的Android Studio 并点击Configure 选择SDK Manger 找到 Android SDK 复制其 Android SDK Location。打开命令行并执行 ： flutter config –android-sdk 复制的地址如果再次flutter doctor时还是有问题请检查\n\nAndroid toolchain - develop for Android devices (Android SDK version 33.0.2)Some Android licenses not accepted. To resolve this, run: flutter doctor–android-licenses\n\n这是有些许可还没开启因此只需要执行：flutter doctor –android-licenses\n\nXcode (not installed)同样是需要安装Xcode为其提供iOS方面的支持，下载地址\nXcode - develop for iOS and macOS (Xcode 13.1)\n\n“✗ CocoaPods not installed.”十分明确未安装CocoaPods，执行：brew install cocoapods最终检查结果为如下所示即为全部安装成功，除了Flutter是必须得，其他看自己项目将要打包成什么项目进行选择安装，并不是必须的。\n","categories":[],"tags":[]},{"title":"flutter从无到有","url":"/posts/c874a042.html","content":"第一步：搭建环境在开始搭建第一个Flutter应用之前，还需要在电脑里安装Flutter环境，如果还未搭建环境请先移步这里。如果环境已安装完毕，那就可以开始，\n第二步：创建应用首先找到即将使用的文件夹并在当前文件夹打开命令行 flutter create 项目名称如图一创建完成后按照下面的命令执行即可进入该项目中运行如图二\n第三步：了解文件完成到这里就可以开始后面定制化的开发了，再次之前可以对每个文件夹进行介绍一下，方便后期开发\npubspec.yamlpubspec.lock与vue一样，是依赖版本锁\nios&#x2F;android&#x2F;web&#x2F;windows&#x2F;macos&#x2F;linux对应的不同平台所内置的引擎能力,作为一名前端人员就可以看Web，这里面就有一个html模版，里面通过js将dart代码动态加载并渲染。\nlib这里面就是主要开发文件夹，可以在这里创建自己的开发文件，其中main.dart就是主入口文件，\n第四步：Flutter 架构概览\nFramework框架层纯dart语言写成的SDK，实现了一套基础库，其中Foundation、Animation、Painting、Gestures都是Google实现的UI、动画渲染、手势交互层面的基础库，Rendering是渲染层，纯抽象布局的一部分，依赖于Foundation、Animation、Painting、Gestures。在这里将会形成一个可渲染对象组成的渲染树，当渲染内容发生变化，这里就会找出变化的内容进行更新，与vue的Render大同小异。Widgets就是Flutter内置的基础组件库。而Material和Cupertinno则是两套不同风格的具体组件库，在开发工程中就回去引用其中的包，如mai.dart中第一行就引用了import ‘package:flutter&#x2F;material.dart’\nEngine引擎层对 Flutter 的核心 API 进行了底层封装并将功能暴露给框架层这里就是Flutter根据不同应用渲染出结果、调用不同平台的原生基础能力，都是通过这里进行总装，通过调用不同内容进行分发调用。\nEmbrdder嵌入层与平台进行整合，将Flutter引擎嵌入对应平台，因为各平台使用的底层语言不同，这里就会产生对应适配，这样Flutter才可以正常渲染。这是Flutter实现跨平台最为核心的一个地方。如果需要对接新平台也将是在这里增加一套新嵌入层。\n第五步：语言介绍常用如下：\n变量声明使用var声明变量、使用const声明常量、可以Object声明一个对象，与TS比较像\n函数//无参数类型-这是不带函数参数或者说参数列表为空String getDefaultErrorMsg() =&gt; &#x27;Unknown Error!&#x27;;//无参数类型-等价于上面函数形式，同样是参数列表为空get getDefaultErrorMsg =&gt; &#x27;Unknown Error!&#x27;;//必需位置参数类型-这里的exception是必需的位置参数String getErrorMsg(Exception exception) =&gt; exception.toString();//必需位置参数类型-这里的exception是必需的位置参数String getErrorMsg(Exception exception) =&gt; exception.toString();//必需位置参数类型-这里的exception是必需的位置参数String getErrorMsg(Exception exception) =&gt; exception.toString();//必需位置参数类型-这里的exception是必需的位置参数String getErrorMsg(Exception exception) =&gt; exception.toString();//注意: 可选命名参数必须在必需位置参数的后面num add(num a, num b, &#123;num c, num d&#125;) &#123;   return a + b + c + d;&#125;void add7([num a, num b], &#123;num c, num d&#125;) &#123;\t// todo&#125;参数默认值(参数默认值只针对可选参数才能添加的。)num add(num a, num b, num c,&#123; num d = 5 &#125;, [num e = 5]&#125;) &#123;    return a + b + c + d;&#125;\nmixinmixin 可以实现类似多重继承的功能，但是实际上和多重继承又不一样。多重继承中相同的函数执行并不会存在 ”父子“ 关系，mixin还可以抽象和重用一系列特性，mixin实际上实现了一条继承链声明，mixin 的顺序代表了继承链的继承顺序，声明在后面的 mixin，一般会最先执行\n异步Future使用Future对象封装了Dart 的异步操作，在定义时进行声明即可，开箱即用。\nStreamStream 是一系列异步事件的序列。其类似于一个异步的 Iterable，不同的是当你向 Iterable 获取下一个事件时它会立即给你，但是 Stream 则不会立即给你而是在它准备好时告诉你。Stream 提供一个异步的数据序列。数据序列包括用户生成的事件和从文件读取的数据。你可以使用 Stream API 中的 listen() 方法和 await for 关键字来处理一个 Stream。当出现错误时，Stream 提供一种处理错误的方式。Stream 有两种类型：Single-Subscription 和 Broadcast\n安利为了减少学习成本，这里推荐一下Kraken，使用它就是做了个桥接层，让我们使用前端技术进行Flutter开发了。\n第四步：实战 、\n因为Flutter本就是支持多运用的，因此本次案例选择Chrome来运行查看效果，这样可以快速的运行并查看效果。Flutter是支持热更新的，但是在第一次使用VScode开发Flutter时，有可能VScode可能配置并没有开启，因此需要再设置中进行配置并重载，如图1，再次运行后就可以支持Flutter的热更新了。开始码代码，下面是lib下main.dart的代码我在下面进行注释，大致了解一下这里每一个方法的作用\nimport &#x27;package:flutter/material.dart&#x27;;void main() &#123; // main函数就是入口函数  runApp(const MyApp()); // MyApp 这里就是下面创建的根组件，runApp就是flutter程序入口，传入的Widget即是我们需要显示的界面Widget，widget就类似于前端的组件&#125;class MyApp extends StatelessWidget &#123; // MyApp继承了无状态的Widget，表示是纯UI组件  const MyApp(&#123;super.key&#125;);  // This widget is the root of your application.  @override  Widget build(BuildContext context) &#123; // build 就相当于Render函数    return MaterialApp( // 表述整个页面的布局      title: &#x27;Flutter Demo&#x27;, // 这里就是APP名称      theme: ThemeData( // 使用主题        // This is the theme of your application.        //        // Try running your application with &quot;flutter run&quot;. You&#x27;ll see the        // application has a blue toolbar. Then, without quitting the app, try        // changing the primarySwatch below to Colors.green and then invoke        // &quot;hot reload&quot; (press &quot;r&quot; in the console where you ran &quot;flutter run&quot;,        // or simply save your changes to &quot;hot reload&quot; in a Flutter IDE).        // Notice that the counter didn&#x27;t reset back to zero; the application        // is not restarted.        primarySwatch: Colors.blue, // 主题颜色是蓝色      ),      home: const MyHomePage(title: &#x27;Frist Flutter!&#x27;), // 内容区域 这里定义了一个MyHomePage的类传参为title 这一块就是图1里面的内容    );  &#125;&#125;class MyHomePage extends StatefulWidget &#123; // 创建MyHomePageWidget，继承与有状态Widget  const MyHomePage(&#123;super.key, required this.title&#125;); // 接收参数 required表示必传，  // This widget is the home page of your application. It is stateful, meaning  // that it has a State object (defined below) that contains fields that affect  // how it looks.  // This class is the configuration for the state. It holds the values (in this  // case the title) provided by the parent (in this case the App widget) and  // used by the build method of the State. Fields in a Widget subclass are  // always marked &quot;final&quot;.  final String title;  @override  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState(); // 创建一个state进行管理计数器部分&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;  int _counter = 0;  void _incrementCounter() &#123; // 定义一个方法    setState(() &#123;      // This call to setState tells the Flutter framework that something has      // changed in this State, which causes it to rerun the build method below      // so that the display can reflect the updated values. If we changed      // _counter without calling setState(), then the build method would not be      // called again, and so nothing would appear to happen.      _counter++;    &#125;);  &#125;  @override  Widget build(BuildContext context) &#123;    // This method is rerun every time setState is called, for instance as done    // by the _incrementCounter method above.    //    // The Flutter framework has been optimized to make rerunning build methods    // fast, so that you can just rebuild anything that needs updating rather    // than having to individually change instances of widgets.    return Scaffold( // 表示是一个容器      appBar: AppBar( // 这里创建一个头部，如图3        // Here we take the value from the MyHomePage object that was created by        // the App.build method, and use it to set our appbar title.        title: Text(widget.title),      ),      body: Center( // 这里表述body是一个用居中容器包裹的，只能接受一个组件，放在child上        // Center is a layout widget. It takes a single child and positions it        // in the middle of the parent.        child: Column( // 创建一行，可以接受多个组件，放在children中          // Column is also a layout widget. It takes a list of children and          // arranges them vertically. By default, it sizes itself to fit its          // children horizontally, and tries to be as tall as its parent.          //          // Invoke &quot;debug painting&quot; (press &quot;p&quot; in the console, choose the          // &quot;Toggle Debug Paint&quot; action from the Flutter Inspector in Android          // Studio, or the &quot;Toggle Debug Paint&quot; command in Visual Studio Code)          // to see the wireframe for each widget.          //          // Column has various properties to control how it sizes itself and          // how it positions its children. Here we use mainAxisAlignment to          // center the children vertically; the main axis here is the vertical          // axis because Columns are vertical (the cross axis would be          // horizontal).          mainAxisAlignment: MainAxisAlignment.center, // 纵向排列方式，这里使用的是居中          children: &lt;Widget&gt;[ // 表示这个数组是一个组件数组            const Text( // 这是创建一个文本              &#x27;You have pushed the button this many times:&#x27;,            ),            Text( //              &#x27;$_counter&#x27;, // 使用$ 接受一个变量              style: Theme.of(context).textTheme.headlineMedium, // 设置文本样式            ),          ],        ),      ),      floatingActionButton: FloatingActionButton( // 创建一个浮动的按钮        onPressed: _incrementCounter, // 相当于点击事件，        tooltip: &#x27;Increment&#x27;, // 长按提示内容，Web中效果是鼠标移入提示        child: const Icon(Icons.add), // 按钮接受一个组件 这里直接创建一个icon       ), // This trailing comma makes auto-formatting nicer for build methods.    );  &#125;&#125;\n在上面的代码中，可以看到flutter就是一个一个的组件堆积而成，基于函数式声明式的开发的有一定的开发基础都可以进行开发，这里面比较难得就是需要知道flutter都提供了那些组件以及组件都需要那些参数、作用都是什么，只要了解了这些flutter开发就不在有任何难度，上面提供了flutter的社区链接和开发文档链接，看完有助于开发。了解完后，看到flutter基于函数式声明式的开发的，跟前端开始有一定差异，那动起手来，多加练习来适应这种开发形式。那就开始开发一些自己页面，只有动手才能加深自己印象，加快学习进度。以下是本次练习的主要代码\n主入口import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_news/constants/Constants.dart&#x27;;import &#x27;events/ThemeEvent.dart&#x27;;import &#x27;pages/HomePage.dart&#x27;;void main() =&gt; runApp(FlutterNews());class FlutterNews extends StatefulWidget &#123;  @override  _FlutterNewsState createState() =&gt; _FlutterNewsState();&#125;class _FlutterNewsState extends State&lt;FlutterNews&gt; &#123;  @override  void initState() &#123;    super.initState();    Constants.eventBus.on&lt;ThemeEvent&gt;().listen((event) &#123;      setState(() &#123;        Constants.currentTheme = event.themeModel;      &#125;);    &#125;);  &#125;  @override  Widget build(BuildContext context) &#123;    var theme = Constants.currentTheme == Constants.dayTheme        ? ThemeData(            brightness: Brightness.light,            primaryColor: Colors.blue,          )        : ThemeData(            brightness: Brightness.dark,            primaryColor: Colors.black,          );    return MaterialApp(      debugShowCheckedModeBanner: false,      theme: theme,      home: HomePage(),    );  &#125;&#125;\n首页import &#x27;dart:convert&#x27;;import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_news/constants/Constants.dart&#x27;;import &#x27;package:flutter_news/events/ThemeEvent.dart&#x27;;import &#x27;package:flutter_news/models/local/Channel.dart&#x27;;import &#x27;package:flutter_news/widgets/Newslistwidget.dart&#x27;;import &#x27;aboutpage.dart&#x27;;class HomePage extends StatefulWidget &#123;  HomePage(&#123;Key key&#125;) : super(key: key);  _HomePageState createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt;    with SingleTickerProviderStateMixin, AutomaticKeepAliveClientMixin &#123;//首页面所有数据的容器  List&lt;dynamic&gt; newsData;  //初始化频道数据的容器  List&lt;Channel&gt; channels;  TabController _tabController;  @override  initState() &#123;    super.initState();    _initChannelData();  &#125;  @override  dispose() &#123;    _tabController.dispose();    super.dispose();  &#125;  //加载初始化json数据  _initChannelData() &#123;    channels = List&lt;Channel&gt;();    Future&lt;String&gt; data =        DefaultAssetBundle.of(context).loadString(&quot;assets/config/channel.json&quot;);    data.then((String value) &#123;      setState(() &#123;        List&lt;dynamic&gt; data = json.decode(value);        _tabController = TabController(          vsync: this,          length: data.length,        );        data.forEach((tmp) &#123;          channels.add(Channel.fromJson(tmp));        &#125;);      &#125;);    &#125;);  &#125;  //初始化标题指示条  Widget _initChannelTitle() &#123;    return TabBar(        controller: _tabController,        indicatorColor: Colors.blue[100],        tabs: channels.map((Channel channel) &#123;          return Tab(            text: channel.channelName,          );        &#125;).toList());  &#125;  //初始化列表内容  Widget _initChannelList() &#123;    return TabBarView(      controller: _tabController,      children: channels.map((Channel channel) &#123;        return NewsListWidget(channel: channel);      &#125;).toList(),    );  &#125;  @override  Widget build(BuildContext context) &#123;    return DefaultTabController(      length: channels.length,      child: Scaffold(        appBar: AppBar(          leading: Icon(Icons.title),          title: Text(Strings.appTitle, style: TextStyle(color: Colors.white)),          bottom: _initChannelTitle(),          actions: &lt;Widget&gt;[            IconButton(              icon: Icon(Icons.assignment),              onPressed: (() &#123;                Navigator.push(                  context,                  MaterialPageRoute(builder: (context) =&gt; AboutPage()),                );              &#125;),            ),            IconButton(                icon: Icon(Icons.autorenew),                onPressed: (() &#123;                  Constants.eventBus.fire(                      Constants.currentTheme == Constants.dayTheme                          ? ThemeEvent(Constants.nightTheme)                          : ThemeEvent(Constants.dayTheme));                &#125;))          ],        ),        body: _initChannelList(),      ),    );  &#125;  @override  bool get wantKeepAlive =&gt; true;&#125;\n\n列表页面import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_news/api/Apis.dart&#x27;;import &#x27;package:flutter_news/events/BeanEvent.dart&#x27;;import &#x27;package:flutter_news/constants/Constants.dart&#x27;;import &#x27;package:flutter_news/models/local/Channel.dart&#x27;;import &#x27;package:flutter_news/models/network/NewsList.dart&#x27;;import &#x27;package:flutter_news/pages/NewsDetailPage.dart&#x27;;class NewsListWidget extends StatefulWidget &#123;  final Channel channel;  NewsListWidget(&#123;Key key, this.channel&#125;) : super(key: key);  _NewsListState createState() =&gt; _NewsListState();&#125;class _NewsListState extends State&lt;NewsListWidget&gt;    with AutomaticKeepAliveClientMixin &#123;  //当前页  int _page = 0;  //网络请求接口  API$Neteast _api;  //该频道下的所有新闻数据  List&lt;News&gt; _datas;  ScrollController _listController;  @override  bool get wantKeepAlive =&gt; true;  @override  void initState() &#123;    super.initState();    _api = API$Neteast();    _datas = [];    _listController = ScrollController();    _listController.addListener(() &#123;      var maxScroll = _listController.position.maxScrollExtent;      var pixels = _listController.position.pixels;      if (maxScroll == pixels) &#123;        _page += 20;        _getNewsList();      &#125;    &#125;);    Constants.eventBus.on&lt;BeanEvent&lt;NewsList&gt;&gt;().listen((event) &#123;      if (widget.channel.channelId == event.id) &#123;        setState(() &#123;          NewsList data = event.data;          _datas.addAll(data.datas);        &#125;);      &#125;    &#125;);    _getNewsList();  &#125;  @override  void dispose() &#123;    _listController.dispose();    super.dispose();  &#125;  Future&lt;Null&gt; _pullToRefresh() async &#123;    _page = 0;    _datas.clear();    _getNewsList();    return null;  &#125;  _getNewsList() &#123;    _api.getNewsList(        widget.channel.channelType, widget.channel.channelId, _page);  &#125;  _onItemClick(int position, News data) &#123;    if (data.url == null || data.url.isEmpty) &#123;      Scaffold.of(context).showSnackBar(SnackBar(        content: new Text(&#x27;缺少新闻链接&#x27;),        duration: Duration(seconds: 1),      ));    &#125; else &#123;      Navigator.of(context).push(MaterialPageRoute(          builder: (ctx) =&gt; NewsDetailPage(                postId: data.postid,                url: data.url,                title: &quot;&quot;,              )));    &#125;  &#125;  Widget _renderRow(int position) &#123;    if (position.isOdd) return Divider();    final index = position ~/ 2;    News data = _datas[index];    return Card(      color: Colors.grey[250],      elevation: 5.0,      child: InkWell(        child: new Column(          crossAxisAlignment: CrossAxisAlignment.start,          children: [            Image.network(data.imgsrc, fit: BoxFit.fitWidth),            Padding(              padding: const EdgeInsets.all(10.0),              child: Text(                data.title,                style: TextStyle(                  fontSize: 16.0,                  fontWeight: FontWeight.bold,                ),              ),            ),            Padding(              padding: data.digest.isEmpty                  ? const EdgeInsets.all(0.0)                  : const EdgeInsets.only(                      left: 10.0, right: 10.0, bottom: 10.0),              child: Text(                data.digest,                style: TextStyle(                  fontSize: 12.0,                ),              ),            ),            Padding(              padding: const EdgeInsets.only(left: 10.0, right: 10.0),              child: Text(                &#x27;时间：$&#123;data.ptime&#125;&#x27;,                style: TextStyle(                  fontSize: 12.0,                ),              ),            ),            Padding(              padding:                  const EdgeInsets.only(left: 10.0, right: 10.0, bottom: 10.0),              child: Text(                &#x27;来源：$&#123;data.source&#125;&#x27;,                style: TextStyle(                  fontSize: 12.0,                ),              ),            )          ],        ),        onTap: () &#123;          _onItemClick(index, data);        &#125;,      ),    );  &#125;  @override  Widget build(BuildContext context) &#123;    if (_datas == null || _datas.isEmpty) &#123;      return Center(child: CircularProgressIndicator());    &#125; else &#123;      Widget listView = ListView.builder(        padding: EdgeInsets.all(10.0),        itemCount: _datas.length * 2,        itemBuilder: (context, i) =&gt; _renderRow(i),        controller: _listController,      );      return RefreshIndicator(child: listView, onRefresh: _pullToRefresh);    &#125;  &#125;&#125;\n基于webView详情import &#x27;package:flutter/cupertino.dart&#x27;;import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_news/constants/constants.dart&#x27;;import &#x27;package:flutter_webview_plugin/flutter_webview_plugin.dart&#x27;;class NewsDetailPage extends StatefulWidget &#123;  final String url;  final String title;  final String postId;  const NewsDetailPage(&#123;Key key, this.postId, this.url, this.title&#125;)      : super(key: key);  @override  State&lt;StatefulWidget&gt; createState() =&gt; NewsDetailPageState();&#125;class NewsDetailPageState extends State&lt;NewsDetailPage&gt; &#123;  bool loaded = false;  String detailDataStr;  final flutterWebViewPlugin = FlutterWebviewPlugin();  NewsDetailPageState(&#123;Key key&#125;);  @override  void initState() &#123;    super.initState();    flutterWebViewPlugin.onStateChanged.listen((state) &#123;      print(&quot;state: $&#123;state.type&#125;&quot;);      if (state.type == WebViewState.finishLoad) &#123;        setState(() &#123;          loaded = true;        &#125;);      &#125;    &#125;);  &#125;  @override  Widget build(BuildContext context) &#123;    List&lt;Widget&gt; titleContent = [];    titleContent.add(Text(        widget.title == null || widget.title.isEmpty            ? Strings.newsDetail            : widget.title,        style: TextStyle(color: Colors.white)));    if (!loaded) &#123;      titleContent.add(CupertinoActivityIndicator());    &#125;    titleContent.add(Container(width: 50.0));    return WebviewScaffold(      url: widget.url,      appBar: AppBar(        title: Row(          mainAxisAlignment: MainAxisAlignment.center,          children: titleContent,        ),        iconTheme: IconThemeData(color: Colors.white),      ),      withZoom: false,      withLocalStorage: true,      withJavascript: true,    );  &#125;&#125;\n请求及数据import &#x27;package:flutter_news/constants/Constants.dart&#x27;;import &#x27;package:http/http.dart&#x27; as http;// 使用网上公共接口class NetWork &#123;  static bool _debug = true;  //网易新闻的host  static String NETEAST_HOST = &quot;https://c.m.163.com/&quot;;  static String getHost(int type) &#123;    switch (type) &#123;      case Constants.TYPE_NET_NETEASE_NEWS:        return NETEAST_HOST;      default:        return &#x27;&#x27;;    &#125;  &#125;  /* 基础GET请求 */  static Future&lt;String&gt; get(String url, &#123;Map&lt;String, String&gt; params&#125;) async &#123;    if (params != null &amp;&amp; params.isNotEmpty) &#123;      StringBuffer sb = StringBuffer(&quot;?&quot;);      params.forEach((key, value) &#123;        sb.write(&quot;$key&quot; + &quot;=&quot; + &quot;$value&quot; + &quot;&amp;&quot;);      &#125;);      String paramStr = sb.toString();      paramStr = paramStr.substring(0, paramStr.length - 1);      url += paramStr;    &#125;    http.Response res = await http.get(url, headers: getCommonHeader());    if (_debug) &#123;      print(&#x27;发起Get请求_____$url|________________$&#123;res.body&#125;|&#x27;);    &#125;    return res.body;  &#125;/* 基础POST请求 */  static Future&lt;String&gt; post(String url, &#123;Map&lt;String, String&gt; params&#125;) async &#123;    http.Response res =        await http.post(url, body: params, headers: getCommonHeader());    if (_debug) &#123;      print(          &#x27;|发起Post请求|_______|$url|______|$&#123;params.toString()&#125;|________|$&#123;res.body&#125;|&#x27;);    &#125;    return res.body;  &#125;  static Map&lt;String, String&gt; getCommonHeader() &#123;    Map&lt;String, String&gt; header = Map();    header[&#x27;User-Agent&#x27;] =        &#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36&#x27;;    return header;  &#125;&#125;\n源码获取地址\n","categories":[],"tags":[]},{"title":"自动创建html","url":"/posts/fd390730.html","content":"直接上代码.这里主要是展示一种思想,将功能近乎相同的小页面抽离为一种配置即可完成的东西,防止自己做无用代码\nconst fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const outFileBasePath = path.join(__dirname, &#x27;../static&#x27;);const dirCache = &#123;&#125;;let pageRouter = [    &#123;        title: &#x27;&#x27;,        description: &#x27;&#x27;,        fileName: &#x27;/introduce/payroll_calculate_incomeTax&#x27;, // 路径        style: &#x27;&#x27;,        script: &#x27;&#x27;,        width: 750,        imgList: [            &#123;                url: &#x27;xxxxxx.png&#x27;,                alt: &#x27;产品介绍图&#x27;,            &#125;        ]    &#125;,    &#123;        title: &#x27;邀请企业，赚大额现金&#x27;,        description: &#x27;&#x27;,        fileName: &#x27;/invitationFriend&#x27;, // 路径        style: `&lt;style&gt;    .content &#123;        background: #FF4A44;        padding-bottom: 67px;    &#125;&lt;/style&gt;        `,        script: &#x27;&#x27;,        width: 500,        imgList: [            &#123;                url: &#x27;xxxxxxxx.png&#x27;,                alt: &#x27;邀请企业福利介绍&#x27;,            &#125;        ]    &#125;];pageRouter.forEach(router =&gt; &#123;    let filePath = outFileBasePath + router.fileName;    let fileContent = `&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;link rel=&quot;icon&quot; href=&quot;./favicon.ico&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;title&gt;$&#123;router.title || &#x27;页面标题&#x27;&#125;&lt;/title&gt;&lt;style&gt;    * &#123;        margin: 0;        padding: 0;        overflow-x: hidden;        -ms-overflow-style: none;        overflow: -moz-scrollbars-none;    &#125;    *::-webkit-scrollbar &#123;        display: none;    &#125;    .content &#123;        width: 100vw;        min-height: 100vh;        background: #ffffff;        display: flex;        justify-content: flex-start;        flex-direction: column;        align-items: center;    &#125;    #mask &#123;        position: fixed;        top: 0;        left: 0;        right: 0;        bottom: 0;        z-index: 1;        background-color: #ffffff;        display: flex;        align-items: center;        justify-content: center;    &#125;    .loading &#123;        position: relative;        width: 30px;        height: 30px;        border: 2px solid rgba(0, 0, 0, 0.2);        border-left-color: #000;        border-radius: 100%;        animation: circle infinite 0.75s linear;    &#125;    @keyframes circle &#123;        0% &#123;            transform: rotate(0);        &#125;        100% &#123;            transform: rotate(360deg);        &#125;    &#125;&lt;/style&gt;$&#123;router.style&#125;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;content&quot;&gt;        $&#123;router.imgList.map(item =&gt; &#123;    return `&lt;img src=&quot;&quot; alt=&quot;$&#123;item.alt&#125;&quot;&gt;`&#125;).join(&#x27;&#x27;)&#125;    &lt;/div&gt;    &lt;div id=&quot;mask&quot;&gt;        &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        let flag = 0;        let imgList = $&#123;JSON.stringify(router.imgList)&#125;;        let imgs = document.querySelectorAll(&#x27;.content img&#x27;);        let mask = document.querySelector(&#x27;#mask&#x27;)        imgs.forEach((e, i) =&gt; &#123;            let url = imgList[i].url + &#x27;?&#x27; + new Date().getTime();            e.src = url;            e.onload = function () &#123;                flag++;                if(flag === $&#123;router.imgList.length&#125;)&#123;                    handleImgWidth();                    window.addEventListener(&quot;resize&quot;, handleImgWidth);                    mask.style.display = &#x27;none&#x27;                &#125;            &#125;        &#125;)        function handleImgWidth() &#123;            let imgArr = document.querySelectorAll(&#x27;.content img&#x27;);            let clientWidth = document.querySelector(&#x27;.content&#x27;).clientWidth;            if (clientWidth &gt; 750) &#123;                for (let i = 0; i &lt; imgArr.length; i++) &#123;                    imgArr[i].style.width = &#x27;$&#123;router.width&#125;px&#x27;                &#125;            &#125; else &#123;                for (let i = 0; i &lt; imgArr.length; i++) &#123;                    imgArr[i].style.width = &#x27;100vw&#x27;                &#125;            &#125;        &#125;    &lt;/script&gt;    $&#123;router.script&#125;&lt;/body&gt;&lt;/html&gt;    `    mkdir(filePath + &#x27;/index.html&#x27;, fileContent)&#125;);function mkdir(filePath, data) &#123;    const arr = filePath.split(&#x27;/&#x27;);    let dir = arr[0];    for (let i = 1; i &lt; arr.length; i++) &#123;        if (dir &amp;&amp; !dirCache[dir] &amp;&amp; !fs.existsSync(dir)) &#123;            dirCache[dir] = true;            fs.mkdirSync(dir);        &#125;        dir = dir + &#x27;/&#x27; + arr[i];    &#125;    fs.writeFileSync(filePath, data, (err) =&gt; &#123;        console.log(err)    &#125;)&#125;\n$ &quot;build&quot;: &quot;node server/statusPage.js &amp;&amp; cross-env BASE_URL=&#x27;https://www.xxxxx.cn&#x27; nuxt build &quot;,\n","categories":[],"tags":[]},{"title":"包管理器命令","url":"/posts/187a3295.html","content":"记录一下各种开发中能够用到的工具命令,方便快速查询到一些常用命令\nyarn设置包下载源：yarn config set npmRegistryServer查看当前包下载源：yarn config get registry自动安装最新版本，会覆盖指定版本号：yarn add [package]一次性添加多个包：yarn add [package] [package] [package]添加指定版本的包：yarn add [package]@[version]安装某个tag：yarn add [package]@[tag]添加到devDependencies：–dev，-D添加到peerDependencies：–peer， -P添加到optionalDependencies：–optional，-O升级到最新版本：yarn upgrade [package]升级到指定版本：yarn upgrade [package]@[version]升级到指定tag：yarn upgrade [package]@[tag]移除包：yarn remove [package]安装所有依赖： yarn，yarn install安装一个包的单一版本：yarn install –flat强制重新下载所有包：yarn install –force只安装生产环境依赖：yarn install –production可以用来查看某个模块的最新版本信息：yarn info [package]列出已缓存的每个包：yarn cache list返回全局缓存位置：yarn cache dir清除缓存：yarn cache clean \nyrmyrm 是一个 yarn源管理器，可以快速地在源间切换查看已有源：yrm ls使用xxx镜像源： yrm use xxx增加一个源：yrm add &lt;源名称&gt; &lt;源地址&gt;删除源: yrm del &lt;源名称&gt;测试xx镜像源访问速度：yrm test taobao查看npm当前镜像源：npm config get registry查看yarn当前镜像源：yarn config get registry \nnpm、cnpm设置包下载源：npm config set registry获取包下载源：npm config get registry安装所有依赖: npm install，npm i安装到全局目录里：-g，–global添加到dependencies：-S，–save添加到devDependencies-D，–save-dev卸载依赖，不卸载package.json的对应信息：npm uninstall [package]卸载全局模块：npm uninstall [package] -g卸载依赖，不卸载package.json中的dependencies对应信息：npm uninstall [package] –save卸载依赖，同时package.json中的devDependencies对应信息：npm uninstall [package] –save-dev更新最新版本:npm update [package]更新到指定版本号:npm update [package]@[version]更新到最后一个新版本:npm install [package]@latest查看项目中模块所在的目录：npm root查看全局安装的模块所在目录：npm root -g查看本地已安装模块的清单列表:npm list， npm ls查看某个包对于各种包的依赖关系：npm view [version] dependencies查看[package]最新的版本号：npm view [package] version查看所有[package]历史版本号：npm view [package] versions查看最新的[package]版本的信息：npm view [package]查看[package]的详细信息：npm info [package]查看本地已安装的[package]的详细信息：npm list [package] ，npm ls [package] 查看[package]包的来源地址：npm view [package] repository.url清除npm的缓存：npm cache clean清除项目中没有被使用的包：npm prune检查模块是否已经过时：npm outdated会打开默认浏览器跳转到github中[package]的页面：npm repo [package]会打开默认浏览器跳转到github中jquery的README.MD文件信息：npm docs [package]会打开默认浏览器跳转到github中jquery的主页：npm home [package]\nnrmnrm can help you easy and fast switch between different npm registries（nrm可以帮助您在不同的npm镜像源之间轻松快速地切换）列出所有源： nrm ls查看当前源：nrm current使用某个源：nrm use &lt;源名称&gt;添加一个源：nrm add &lt;源名称&gt; &lt;源地址&gt;删除一个源：nrm del &lt;源名称&gt;  nrm查看更多指令\npnpmpnpm也称高性能npm,相比npm、yarn优势在于节省磁盘空间并提升安装速度。安装依赖：pnpm install xxx&#x2F;pnpm i xxx设置包下载源：pnpm config set registry获取包下载源：pnpm config get registry安装依赖到dependencies:pnpm add安装依赖到devDependencies：pnpm add -D更新依赖包：pnpm update [package]，pnpm up [package]\t删除依赖包：pnpm remove [package]所有命令查询文档：pnpm中文文档-CLI命令\nnvm安装指定版本node：nvm install vx.x.x安装最新node：nvm install stable设置node默认版：nvm alias default [node版本号]删除指定版本node：nvm uninstall vx.x.x查看所有已安装版本： nvm ls，nvm list列出所以远程服务器的版本：nvm ls-remote显示当前的版本：nvm current给不同的版本号添加别名：nvm alias删除已定义的别名：nvm unalias在当前版本node下，重新全局安装指定版本号的npm包：nvm reinstall-packages查看当前版本： nvm -vnvm官方文档\nwebpack\nvite\n","categories":[],"tags":[]}]