<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mac搭建Flutter环境</title>
    <url>/posts/662afcd5.html</url>
    <content><![CDATA[<p>安装Flutter学习网站：<a href="https://flutter.cn/docs/get-started/install">Flutter安装文档</a></p>
<h3 id="安装Flutter-SDK（全程以Mac为例）"><a href="#安装Flutter-SDK（全程以Mac为例）" class="headerlink" title="安装Flutter SDK（全程以Mac为例）"></a>安装Flutter SDK（全程以Mac为例）</h3><p>这里有两种方式进行安装，分别是使用安装包和使用git进行操作<br>:::info<br>方法一<br><a href="https://flutter.cn/docs/development/tools/sdk/releases">Flutter版本列表</a>在这里选择合适的版本进行下载<br>下载完成后解压并<br>方式二<br>找到自己准备存放Flutter的文件夹 并按照如下操作<br>:::</p>
<pre class="highlight"><code class="hljs bash">// 开始下载<br>$ git <span class="hljs-built_in">clone</span> https://github.com/flutter/flutter.git -b stable<br></code></pre>
<pre class="highlight"><code class="hljs bash">// 查询自己默认使用的哪个shell<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span><br>// bash<br>$ vim ~/.bash_profile<br>// zsh<br>$ vim ~/.zshrc<br>// 添加镜像<br>$ <span class="hljs-built_in">export</span> PUB_HOSTED_URL=https://mirrors.tuna.tsinghua.edu.cn/dart-pub<br>$ <span class="hljs-built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://mirrors.tuna.tsinghua.edu.cn/flutter<br>$ <span class="hljs-built_in">export</span> FLUTTER=~/xxx // 自己文件位置 <br>$ <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$FLUTTER</span>/bin:<span class="hljs-variable">$PATH</span><br>// 退出编辑 ⇧+q 并输入 wq！<br>// 重载命令<br>// bash<br>$ <span class="hljs-built_in">source</span> ~/.bash_profile<br>// zsh<br>$ <span class="hljs-built_in">source</span> ~/.zshrc<br>// flutter doctor命令来查看当前环境是否需要安装其他的依赖 全部都出现对钩就表明检查通过<br>$ flutter doctor<br></code></pre>
<h3 id="检查时出现的问题"><a href="#检查时出现的问题" class="headerlink" title="检查时出现的问题"></a>检查时出现的问题</h3><ol>
<li>Android Studio (not installed)<br>因为Flutter需要依赖Android Studio来为提供Android平台的支持，因此需要安装全量安装Android Studio，<a href="https://developer.android.google.cn/studio">Android Studio安装地址</a>，</li>
<li>Android toolchain - develop for Android devices —–[X]<br>Unable to locate Android SDK.</li>
</ol>
<p>Install Android Studio from:<br><a href="https://developer.android.com/studio/index.html">https://developer.android.com/studio/index.html</a><br>On first launch it will assist you in installing the Android SDK<br>components.<br>(or visit <a href="https://flutter.dev/docs/get-started/install/macos#android-setup">https://flutter.dev/docs/get-started/install/macos#android-setup</a><br>for detailed instructions).<br>If the Android SDK has been installed to a custom location, please use<br><code>flutter config --android-sdk</code> to update to that location.<br><strong>打开下载的Android Studio 并点击Configure 选择SDK Manger 找到 Android SDK 复制其 Android SDK Location。打开命令行并执行 ： flutter config –android-sdk 复制的地址</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680701064513-79eeffb5-0276-4482-9eff-4a664a029c11.png#averageHue=%234f515e&clientId=u708b8274-f4c1-4&from=paste&height=310&id=ubc603d7a&name=image.png&originHeight=620&originWidth=1626&originalType=binary&ratio=2&rotation=0&showTitle=false&size=471532&status=done&style=none&taskId=ufcfac575-2689-4d05-8b20-ae83b3c2014&title=&width=813" alt="image.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680701064513-79eeffb5-0276-4482-9eff-4a664a029c11.png#averageHue=%234f515e&clientId=u708b8274-f4c1-4&from=paste&height=310&id=ubc603d7a&name=image.png&originHeight=620&originWidth=1626&originalType=binary&ratio=2&rotation=0&showTitle=false&size=471532&status=done&style=none&taskId=ufcfac575-2689-4d05-8b20-ae83b3c2014&title=&width=813" class="lozad post-image"><br><strong>如果再次flutter doctor时还是有问题请检查</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680702481156-97a9b94c-0e5f-492e-b280-3d0216838548.png#averageHue=%233d4046&clientId=u708b8274-f4c1-4&from=paste&height=265&id=u581ca1aa&name=image.png&originHeight=530&originWidth=1644&originalType=binary&ratio=2&rotation=0&showTitle=false&size=152265&status=done&style=none&taskId=ued2a2fc9-5dda-4e43-822b-5aa7a5d6c2d&title=&width=822" alt="image.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680702481156-97a9b94c-0e5f-492e-b280-3d0216838548.png#averageHue=%233d4046&clientId=u708b8274-f4c1-4&from=paste&height=265&id=u581ca1aa&name=image.png&originHeight=530&originWidth=1644&originalType=binary&ratio=2&rotation=0&showTitle=false&size=152265&status=done&style=none&taskId=ued2a2fc9-5dda-4e43-822b-5aa7a5d6c2d&title=&width=822" class="lozad post-image"></p>
<ol start="3">
<li>Android toolchain - develop for Android devices (Android SDK version 33.0.2)<br>Some Android licenses not accepted. To resolve this, run: flutter doctor–android-licenses</li>
</ol>
<p><strong>这是有些许可还没开启因此只需要执行：flutter doctor –android-licenses</strong></p>
<ol start="4">
<li>Xcode (not installed)<br>同样是需要安装Xcode为其提供iOS方面的支持，<a href="https://developer.apple.com/xcode/">下载地址</a></li>
<li>Xcode - develop for iOS and macOS (Xcode 13.1)</li>
</ol>
<p>“✗ CocoaPods not installed.”<br><strong>十分明确未安装CocoaPods，执行：brew install cocoapods</strong><br>最终检查结果为如下所示即为全部安装成功，除了Flutter是必须得，其他看自己项目将要打包成什么项目进行选择安装，并不是必须的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680705825519-95fff26c-a0aa-43e2-b750-3440ae2c7300.png#averageHue=%23f1f1f0&clientId=u708b8274-f4c1-4&from=paste&height=192&id=ua8208f34&name=image.png&originHeight=384&originWidth=1024&originalType=binary&ratio=2&rotation=0&showTitle=false&size=218444&status=done&style=none&taskId=u8e7dc8e1-c960-4141-bd67-35be10a41b6&title=&width=512" alt="image.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680705825519-95fff26c-a0aa-43e2-b750-3440ae2c7300.png#averageHue=%23f1f1f0&clientId=u708b8274-f4c1-4&from=paste&height=192&id=ua8208f34&name=image.png&originHeight=384&originWidth=1024&originalType=binary&ratio=2&rotation=0&showTitle=false&size=218444&status=done&style=none&taskId=u8e7dc8e1-c960-4141-bd67-35be10a41b6&title=&width=512" class="lozad post-image"></p>
]]></content>
      <categories>
        <category>拓展学习</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter从无到有</title>
    <url>/posts/c874a042.html</url>
    <content><![CDATA[<h2 id="第一步：搭建环境"><a href="#第一步：搭建环境" class="headerlink" title="第一步：搭建环境"></a>第一步：搭建环境</h2><p>在开始搭建第一个Flutter应用之前，还需要在电脑里安装Flutter环境，如果还未搭建环境请先移步<a href="https://www.liyueer.cn/posts/662afcd5.html">这里</a>。如果环境已安装完毕，那就可以开始，</p>
<h2 id="第二步：创建应用"><a href="#第二步：创建应用" class="headerlink" title="第二步：创建应用"></a>第二步：创建应用</h2><p>首先找到即将使用的文件夹并在当前文件夹打开命令行 flutter create 项目名称如图一<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680708104712-92eb1747-4eab-4fcd-917a-65a4a7d0683e.png#averageHue=%23f7f7f6&clientId=u030161f4-ca59-4&from=paste&height=310&id=u64205e39&name=image.png&originHeight=1234&originWidth=1058&originalType=binary&ratio=2&rotation=0&showTitle=true&size=579264&status=done&style=none&taskId=u9eef0d84-da7a-4b88-a25e-b2305e0e31e&title=%E5%9B%BE%E4%B8%80&width=266" alt="image.png" title="图一" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680708104712-92eb1747-4eab-4fcd-917a-65a4a7d0683e.png#averageHue=%23f7f7f6&clientId=u030161f4-ca59-4&from=paste&height=310&id=u64205e39&name=image.png&originHeight=1234&originWidth=1058&originalType=binary&ratio=2&rotation=0&showTitle=true&size=579264&status=done&style=none&taskId=u9eef0d84-da7a-4b88-a25e-b2305e0e31e&title=%E5%9B%BE%E4%B8%80&width=266" class="lozad post-image"><img src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680708294450-ddc597fe-d5b2-40ad-826b-ab6ded77156e.png#averageHue=%23f9f9f9&clientId=u030161f4-ca59-4&from=paste&height=309&id=ud59f23fa&name=image.png&originHeight=1770&originWidth=978&originalType=binary&ratio=2&rotation=0&showTitle=true&size=72673&status=done&style=none&taskId=ud9923ad5-b863-4f18-87b8-aca1906af32&title=%E5%9B%BE%E4%BA%8C&width=171" alt="image.png" title="图二" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680708294450-ddc597fe-d5b2-40ad-826b-ab6ded77156e.png#averageHue=%23f9f9f9&clientId=u030161f4-ca59-4&from=paste&height=309&id=ud59f23fa&name=image.png&originHeight=1770&originWidth=978&originalType=binary&ratio=2&rotation=0&showTitle=true&size=72673&status=done&style=none&taskId=ud9923ad5-b863-4f18-87b8-aca1906af32&title=%E5%9B%BE%E4%BA%8C&width=171" class="lozad post-image"><br>创建完成后按照下面的命令执行即可进入该项目中运行如图二</p>
<h2 id="第三步：了解文件"><a href="#第三步：了解文件" class="headerlink" title="第三步：了解文件"></a>第三步：了解文件</h2><p>完成到这里就可以开始后面定制化的开发了，再次之前可以对每个文件夹进行介绍一下，方便后期开发<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680708461836-b8574456-a03d-4354-9c93-18345e8b421d.png#averageHue=%2325272a&clientId=u030161f4-ca59-4&from=paste&height=407&id=uf888b3d3&name=image.png&originHeight=814&originWidth=568&originalType=binary&ratio=2&rotation=0&showTitle=false&size=66414&status=done&style=none&taskId=u5ad4a3c6-9cea-4792-befd-9dbd921fdd7&title=&width=284" alt="image.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680708461836-b8574456-a03d-4354-9c93-18345e8b421d.png#averageHue=%2325272a&clientId=u030161f4-ca59-4&from=paste&height=407&id=uf888b3d3&name=image.png&originHeight=814&originWidth=568&originalType=binary&ratio=2&rotation=0&showTitle=false&size=66414&status=done&style=none&taskId=u5ad4a3c6-9cea-4792-befd-9dbd921fdd7&title=&width=284" class="lozad post-image"></p>
<h3 id="pubspec-yaml"><a href="#pubspec-yaml" class="headerlink" title="pubspec.yaml"></a>pubspec.yaml</h3><h3 id="pubspec-lock"><a href="#pubspec-lock" class="headerlink" title="pubspec.lock"></a>pubspec.lock</h3><p>与vue一样，是依赖版本锁</p>
<h3 id="ios-x2F-android-x2F-web-x2F-windows-x2F-macos-x2F-linux"><a href="#ios-x2F-android-x2F-web-x2F-windows-x2F-macos-x2F-linux" class="headerlink" title="ios&#x2F;android&#x2F;web&#x2F;windows&#x2F;macos&#x2F;linux"></a>ios&#x2F;android&#x2F;web&#x2F;windows&#x2F;macos&#x2F;linux</h3><p>对应的不同平台所内置的引擎能力,作为一名前端人员就可以看Web，这里面就有一个html模版，里面通过js将dart代码动态加载并渲染。</p>
<h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><p>这里面就是主要开发文件夹，可以在这里创建自己的开发文件，其中main.dart就是主入口文件，</p>
<h2 id="第四步：Flutter-架构概览"><a href="#第四步：Flutter-架构概览" class="headerlink" title="第四步：Flutter 架构概览"></a>第四步：Flutter 架构概览</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680712075341-3afb5769-fb57-47be-8d06-74f8709bc4b9.png#averageHue=%2367b567&clientId=u030161f4-ca59-4&from=paste&id=u8a9d8ae4&name=image.png&originHeight=1506&originWidth=1836&originalType=url&ratio=2&rotation=0&showTitle=false&size=802610&status=done&style=none&taskId=u8363cc05-59ef-4c25-bed7-1ffe9bbeb57&title=" alt="image.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680712075341-3afb5769-fb57-47be-8d06-74f8709bc4b9.png#averageHue=%2367b567&clientId=u030161f4-ca59-4&from=paste&id=u8a9d8ae4&name=image.png&originHeight=1506&originWidth=1836&originalType=url&ratio=2&rotation=0&showTitle=false&size=802610&status=done&style=none&taskId=u8363cc05-59ef-4c25-bed7-1ffe9bbeb57&title=" class="lozad post-image"></p>
<h3 id="Framework框架层"><a href="#Framework框架层" class="headerlink" title="Framework框架层"></a>Framework框架层</h3><p>纯dart语言写成的SDK，实现了一套基础库，其中Foundation、Animation、Painting、Gestures都是Google实现的UI、动画渲染、手势交互层面的基础库，Rendering是渲染层，纯抽象布局的一部分，依赖于Foundation、Animation、Painting、Gestures。在这里将会形成一个可渲染对象组成的渲染树，当渲染内容发生变化，这里就会找出变化的内容进行更新，与vue的Render大同小异。Widgets就是Flutter内置的基础组件库。而Material和Cupertinno则是两套不同风格的具体组件库，在开发工程中就回去引用其中的包，如mai.dart中第一行就引用了import ‘package:flutter&#x2F;material.dart’</p>
<h3 id="Engine引擎层"><a href="#Engine引擎层" class="headerlink" title="Engine引擎层"></a>Engine引擎层</h3><p>对 Flutter 的核心 API 进行了底层封装并将功能暴露给框架层这里就是Flutter根据不同应用渲染出结果、调用不同平台的原生基础能力，都是通过这里进行总装，通过调用不同内容进行分发调用。</p>
<h3 id="Embrdder嵌入层"><a href="#Embrdder嵌入层" class="headerlink" title="Embrdder嵌入层"></a>Embrdder嵌入层</h3><p>与平台进行整合，将Flutter引擎嵌入对应平台，因为各平台使用的底层语言不同，这里就会产生对应适配，这样Flutter才可以正常渲染。这是Flutter实现跨平台最为核心的一个地方。如果需要对接新平台也将是在这里增加一套新嵌入层。</p>
<h2 id="第五步：语言介绍"><a href="#第五步：语言介绍" class="headerlink" title="第五步：语言介绍"></a>第五步：语言介绍</h2><p>常用如下：</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>使用var声明变量、使用const声明常量、可以Object声明一个对象，与TS比较像</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre class="highlight"><code class="hljs bash">//无参数类型-这是不带函数参数或者说参数列表为空<br>String getDefaultErrorMsg() =&gt; <span class="hljs-string">&#x27;Unknown Error!&#x27;</span>;<br>//无参数类型-等价于上面函数形式，同样是参数列表为空<br>get getDefaultErrorMsg =&gt; <span class="hljs-string">&#x27;Unknown Error!&#x27;</span>;<br>//必需位置参数类型-这里的exception是必需的位置参数<br>String getErrorMsg(Exception exception) =&gt; exception.toString();<br>//必需位置参数类型-这里的exception是必需的位置参数<br>String getErrorMsg(Exception exception) =&gt; exception.toString();<br>//必需位置参数类型-这里的exception是必需的位置参数<br>String getErrorMsg(Exception exception) =&gt; exception.toString();<br>//必需位置参数类型-这里的exception是必需的位置参数<br>String getErrorMsg(Exception exception) =&gt; exception.toString();<br>//注意: 可选命名参数必须在必需位置参数的后面<br>num add(num a, num b, &#123;num c, num d&#125;) &#123;<br>   <span class="hljs-built_in">return</span> a + b + c + d;<br>&#125;<br>void add7([num a, num b], &#123;num c, num d&#125;) &#123;<br>	// todo<br>&#125;<br>参数默认值(参数默认值只针对可选参数才能添加的。)<br>num add(num a, num b, num c,&#123; num d = 5 &#125;, [num e = 5]&#125;) &#123;<br>    <span class="hljs-built_in">return</span> a + b + c + d;<br>&#125;<br></code></pre>
<h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><p>mixin 可以实现类似多重继承的功能，但是实际上和多重继承又不一样。多重继承中相同的函数执行并不会存在 ”父子“ 关系，mixin还可以抽象和重用一系列特性，mixin实际上实现了一条继承链声明，mixin 的顺序代表了继承链的继承顺序，声明在后面的 mixin，一般会最先执行</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>Future使用Future对象封装了Dart 的异步操作，在定义时进行声明即可，开箱即用。</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Stream 是一系列异步事件的序列。其类似于一个异步的 Iterable，不同的是当你向 Iterable 获取下一个事件时它会立即给你，但是 Stream 则不会立即给你而是在它准备好时告诉你。Stream 提供一个异步的数据序列。数据序列包括用户生成的事件和从文件读取的数据。你可以使用 Stream API 中的 listen() 方法和 await for 关键字来处理一个 Stream。当出现错误时，Stream 提供一种处理错误的方式。Stream 有两种类型：Single-Subscription 和 Broadcast</p>
<h3 id="安利"><a href="#安利" class="headerlink" title="安利"></a>安利</h3><p>为了减少学习成本，这里推荐一下<a href="https://openkraken.com/guide">Kraken</a>，使用它就是做了个桥接层，让我们使用前端技术进行Flutter开发了。</p>
<h2 id="第四步：实战"><a href="#第四步：实战" class="headerlink" title="第四步：实战"></a>第四步：实战</h2><p> 、</p>
<p>因为Flutter本就是支持多运用的，因此本次案例选择Chrome来运行查看效果，这样可以快速的运行并查看效果。Flutter是支持热更新的，但是在第一次使用VScode开发Flutter时，有可能VScode可能配置并没有开启，因此需要再设置中进行配置并重载，如图1，再次运行后就可以支持Flutter的热更新了。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680795305231-7fc77ac5-6890-4e33-a8cb-0c49ed5a4bcd.png#averageHue=%232b2b2b&clientId=ud048ed5b-f283-4&from=paste&height=334&id=ud008bf8a&name=image.png&originHeight=912&originWidth=1092&originalType=binary&ratio=2&rotation=0&showTitle=false&size=120205&status=done&style=none&taskId=ue6fc0743-d9b2-4196-9e2b-6d5e103e4df&title=&width=400" alt="image.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680795305231-7fc77ac5-6890-4e33-a8cb-0c49ed5a4bcd.png#averageHue=%232b2b2b&clientId=ud048ed5b-f283-4&from=paste&height=334&id=ud008bf8a&name=image.png&originHeight=912&originWidth=1092&originalType=binary&ratio=2&rotation=0&showTitle=false&size=120205&status=done&style=none&taskId=ue6fc0743-d9b2-4196-9e2b-6d5e103e4df&title=&width=400" class="lozad post-image"><br>开始码代码，下面是lib下main.dart的代码我在下面进行注释，大致了解一下这里每一个方法的作用</p>
<pre class="highlight"><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123; <span class="hljs-comment">// main函数就是入口函数</span><br>  runApp(<span class="hljs-keyword">const</span> MyApp()); <span class="hljs-comment">// MyApp 这里就是下面创建的根组件，runApp就是flutter程序入口，传入的Widget即是我们需要显示的界面Widget，widget就类似于前端的组件</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123; <span class="hljs-comment">// MyApp继承了无状态的Widget，表示是纯UI组件</span><br>  <span class="hljs-keyword">const</span> MyApp(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-comment">// This widget is the root of your application.</span><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123; <span class="hljs-comment">// build 就相当于Render函数</span><br>    <span class="hljs-keyword">return</span> MaterialApp( <span class="hljs-comment">// 表述整个页面的布局</span><br>      title: <span class="hljs-string">&#x27;Flutter Demo&#x27;</span>, <span class="hljs-comment">// 这里就是APP名称</span><br>      theme: ThemeData( <span class="hljs-comment">// 使用主题</span><br>        <span class="hljs-comment">// This is the theme of your application.</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// Try running your application with &quot;flutter run&quot;. You&#x27;ll see the</span><br>        <span class="hljs-comment">// application has a blue toolbar. Then, without quitting the app, try</span><br>        <span class="hljs-comment">// changing the primarySwatch below to Colors.green and then invoke</span><br>        <span class="hljs-comment">// &quot;hot reload&quot; (press &quot;r&quot; in the console where you ran &quot;flutter run&quot;,</span><br>        <span class="hljs-comment">// or simply save your changes to &quot;hot reload&quot; in a Flutter IDE).</span><br>        <span class="hljs-comment">// Notice that the counter didn&#x27;t reset back to zero; the application</span><br>        <span class="hljs-comment">// is not restarted.</span><br>        primarySwatch: Colors.blue, <span class="hljs-comment">// 主题颜色是蓝色</span><br>      ),<br>      home: <span class="hljs-keyword">const</span> MyHomePage(title: <span class="hljs-string">&#x27;Frist Flutter!&#x27;</span>), <span class="hljs-comment">// 内容区域 这里定义了一个MyHomePage的类传参为title 这一块就是图1里面的内容</span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123; <span class="hljs-comment">// 创建MyHomePageWidget，继承与有状态Widget</span><br>  <span class="hljs-keyword">const</span> MyHomePage(&#123;<span class="hljs-keyword">super</span>.key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.title&#125;); <span class="hljs-comment">// 接收参数 required表示必传，</span><br><br>  <span class="hljs-comment">// This widget is the home page of your application. It is stateful, meaning</span><br>  <span class="hljs-comment">// that it has a State object (defined below) that contains fields that affect</span><br>  <span class="hljs-comment">// how it looks.</span><br><br>  <span class="hljs-comment">// This class is the configuration for the state. It holds the values (in this</span><br>  <span class="hljs-comment">// case the title) provided by the parent (in this case the App widget) and</span><br>  <span class="hljs-comment">// used by the build method of the State. Fields in a Widget subclass are</span><br>  <span class="hljs-comment">// always marked &quot;final&quot;.</span><br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> title;<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState(); <span class="hljs-comment">// 创建一个state进行管理计数器部分</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">void</span> _incrementCounter() &#123; <span class="hljs-comment">// 定义一个方法</span><br>    setState(() &#123;<br>      <span class="hljs-comment">// This call to setState tells the Flutter framework that something has</span><br>      <span class="hljs-comment">// changed in this State, which causes it to rerun the build method below</span><br>      <span class="hljs-comment">// so that the display can reflect the updated values. If we changed</span><br>      <span class="hljs-comment">// _counter without calling setState(), then the build method would not be</span><br>      <span class="hljs-comment">// called again, and so nothing would appear to happen.</span><br>      _counter++;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// This method is rerun every time setState is called, for instance as done</span><br>    <span class="hljs-comment">// by the _incrementCounter method above.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// The Flutter framework has been optimized to make rerunning build methods</span><br>    <span class="hljs-comment">// fast, so that you can just rebuild anything that needs updating rather</span><br>    <span class="hljs-comment">// than having to individually change instances of widgets.</span><br>    <span class="hljs-keyword">return</span> Scaffold( <span class="hljs-comment">// 表示是一个容器</span><br>      appBar: AppBar( <span class="hljs-comment">// 这里创建一个头部，如图3</span><br>        <span class="hljs-comment">// Here we take the value from the MyHomePage object that was created by</span><br>        <span class="hljs-comment">// the App.build method, and use it to set our appbar title.</span><br>        title: Text(widget.title),<br>      ),<br>      body: Center( <span class="hljs-comment">// 这里表述body是一个用居中容器包裹的，只能接受一个组件，放在child上</span><br>        <span class="hljs-comment">// Center is a layout widget. It takes a single child and positions it</span><br>        <span class="hljs-comment">// in the middle of the parent.</span><br>        child: Column( <span class="hljs-comment">// 创建一行，可以接受多个组件，放在children中</span><br>          <span class="hljs-comment">// Column is also a layout widget. It takes a list of children and</span><br>          <span class="hljs-comment">// arranges them vertically. By default, it sizes itself to fit its</span><br>          <span class="hljs-comment">// children horizontally, and tries to be as tall as its parent.</span><br>          <span class="hljs-comment">//</span><br>          <span class="hljs-comment">// Invoke &quot;debug painting&quot; (press &quot;p&quot; in the console, choose the</span><br>          <span class="hljs-comment">// &quot;Toggle Debug Paint&quot; action from the Flutter Inspector in Android</span><br>          <span class="hljs-comment">// Studio, or the &quot;Toggle Debug Paint&quot; command in Visual Studio Code)</span><br>          <span class="hljs-comment">// to see the wireframe for each widget.</span><br>          <span class="hljs-comment">//</span><br>          <span class="hljs-comment">// Column has various properties to control how it sizes itself and</span><br>          <span class="hljs-comment">// how it positions its children. Here we use mainAxisAlignment to</span><br>          <span class="hljs-comment">// center the children vertically; the main axis here is the vertical</span><br>          <span class="hljs-comment">// axis because Columns are vertical (the cross axis would be</span><br>          <span class="hljs-comment">// horizontal).</span><br>          mainAxisAlignment: MainAxisAlignment.center, <span class="hljs-comment">// 纵向排列方式，这里使用的是居中</span><br>          children: &lt;Widget&gt;[ <span class="hljs-comment">// 表示这个数组是一个组件数组</span><br>            <span class="hljs-keyword">const</span> Text( <span class="hljs-comment">// 这是创建一个文本</span><br>              <span class="hljs-string">&#x27;You have pushed the button this many times:&#x27;</span>,<br>            ),<br>            Text( <span class="hljs-comment">//</span><br>              <span class="hljs-string">&#x27;<span class="hljs-subst">$_counter</span>&#x27;</span>, <span class="hljs-comment">// 使用$ 接受一个变量</span><br>              style: Theme.of(context).textTheme.headlineMedium, <span class="hljs-comment">// 设置文本样式</span><br>            ),<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton( <span class="hljs-comment">// 创建一个浮动的按钮</span><br>        onPressed: _incrementCounter, <span class="hljs-comment">// 相当于点击事件，</span><br>        tooltip: <span class="hljs-string">&#x27;Increment&#x27;</span>, <span class="hljs-comment">// 长按提示内容，Web中效果是鼠标移入提示</span><br>        child: <span class="hljs-keyword">const</span> Icon(Icons.add), <span class="hljs-comment">// 按钮接受一个组件 这里直接创建一个icon </span><br>      ), <span class="hljs-comment">// This trailing comma makes auto-formatting nicer for build methods.</span><br>    );<br>  &#125;<br>&#125;<br><br></code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680797189832-3008d7ff-d51d-4fb4-8033-14f72a97853d.png#averageHue=%23f9f9f9&clientId=ud048ed5b-f283-4&from=paste&height=539&id=u319b5719&name=image.png&originHeight=1634&originWidth=1000&originalType=binary&ratio=2&rotation=0&showTitle=true&size=72044&status=done&style=none&taskId=u1e0b7762-65f5-428d-91b4-f0e8c2a0561&title=%E5%9B%BE2&width=330" alt="image.png" title="图2" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680797189832-3008d7ff-d51d-4fb4-8033-14f72a97853d.png#averageHue=%23f9f9f9&clientId=ud048ed5b-f283-4&from=paste&height=539&id=u319b5719&name=image.png&originHeight=1634&originWidth=1000&originalType=binary&ratio=2&rotation=0&showTitle=true&size=72044&status=done&style=none&taskId=u1e0b7762-65f5-428d-91b4-f0e8c2a0561&title=%E5%9B%BE2&width=330" class="lozad post-image"><img src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680797282733-488adf78-b680-4df1-b9cf-633e8069f9dd.png#averageHue=%234c95ea&clientId=ud048ed5b-f283-4&from=paste&height=38&id=uac0680a5&name=image.png&originHeight=124&originWidth=998&originalType=binary&ratio=2&rotation=0&showTitle=true&size=17024&status=done&style=none&taskId=u78c2b95d-0218-4f9b-aba6-b197466a9b4&title=%E5%9B%BE3&width=307" alt="image.png" title="图3" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680797282733-488adf78-b680-4df1-b9cf-633e8069f9dd.png#averageHue=%234c95ea&clientId=ud048ed5b-f283-4&from=paste&height=38&id=uac0680a5&name=image.png&originHeight=124&originWidth=998&originalType=binary&ratio=2&rotation=0&showTitle=true&size=17024&status=done&style=none&taskId=u78c2b95d-0218-4f9b-aba6-b197466a9b4&title=%E5%9B%BE3&width=307" class="lozad post-image"><img src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680796241953-b7ad9626-86e2-4764-bfe2-9ab7d5e20efe.png#averageHue=%23f9f9f9&clientId=ud048ed5b-f283-4&from=paste&height=437&id=u128c34ab&name=image.png&originHeight=1678&originWidth=1262&originalType=binary&ratio=2&rotation=0&showTitle=true&size=65846&status=done&style=none&taskId=uf3cc3987-3156-4cd3-9c75-70c559f2eae&title=%E5%9B%BE4&width=329" alt="image.png" title="图4" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680796241953-b7ad9626-86e2-4764-bfe2-9ab7d5e20efe.png#averageHue=%23f9f9f9&clientId=ud048ed5b-f283-4&from=paste&height=437&id=u128c34ab&name=image.png&originHeight=1678&originWidth=1262&originalType=binary&ratio=2&rotation=0&showTitle=true&size=65846&status=done&style=none&taskId=uf3cc3987-3156-4cd3-9c75-70c559f2eae&title=%E5%9B%BE4&width=329" class="lozad post-image"><img src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680796279220-220654c9-6850-4085-a322-ddffcfbc9871.png#averageHue=%23f7f7f7&clientId=ud048ed5b-f283-4&from=paste&height=195&id=u9767b814&name=image.png&originHeight=246&originWidth=222&originalType=binary&ratio=2&rotation=0&showTitle=true&size=13520&status=done&style=none&taskId=u8cf6b6e5-482c-4852-8ef1-70e402a7df9&title=%E5%9B%BE5&width=176" alt="image.png" title="图5" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1680796279220-220654c9-6850-4085-a322-ddffcfbc9871.png#averageHue=%23f7f7f7&clientId=ud048ed5b-f283-4&from=paste&height=195&id=u9767b814&name=image.png&originHeight=246&originWidth=222&originalType=binary&ratio=2&rotation=0&showTitle=true&size=13520&status=done&style=none&taskId=u8cf6b6e5-482c-4852-8ef1-70e402a7df9&title=%E5%9B%BE5&width=176" class="lozad post-image"><br>在上面的代码中，可以看到flutter就是一个一个的组件堆积而成，基于函数式声明式的开发的有一定的开发基础都可以进行开发，这里面比较难得就是需要知道flutter都提供了那些组件以及组件都需要那些参数、作用都是什么，只要了解了这些flutter开发就不在有任何难度，上面提供了flutter的社区链接和开发文档链接，看完有助于开发。<br>了解完后，看到flutter基于函数式声明式的开发的，跟前端开始有一定差异，那动起手来，多加练习来适应这种开发形式。那就开始开发一些自己页面，只有动手才能加深自己印象，加快学习进度。<br>以下是本次练习的主要代码</p>
<h3 id="主入口"><a href="#主入口" class="headerlink" title="主入口"></a>主入口</h3><pre class="highlight"><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_news/constants/Constants.dart&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;events/ThemeEvent.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;pages/HomePage.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() =&gt; runApp(FlutterNews());<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlutterNews</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  _FlutterNewsState createState() =&gt; _FlutterNewsState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_FlutterNewsState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">FlutterNews</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    Constants.eventBus.<span class="hljs-keyword">on</span>&lt;ThemeEvent&gt;().listen((event) &#123;<br>      setState(() &#123;<br>        Constants.currentTheme = event.themeModel;<br>      &#125;);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">var</span> theme = Constants.currentTheme == Constants.dayTheme<br>        ? ThemeData(<br>            brightness: Brightness.light,<br>            primaryColor: Colors.blue,<br>          )<br>        : ThemeData(<br>            brightness: Brightness.dark,<br>            primaryColor: Colors.black,<br>          );<br><br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      debugShowCheckedModeBanner: <span class="hljs-keyword">false</span>,<br>      theme: theme,<br>      home: HomePage(),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre>
<h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><pre class="highlight"><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:convert&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_news/constants/Constants.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_news/events/ThemeEvent.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_news/models/local/Channel.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_news/widgets/Newslistwidget.dart&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;aboutpage.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  HomePage(&#123;Key key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  _HomePageState createState() =&gt; _HomePageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_HomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HomePage</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">SingleTickerProviderStateMixin</span>, <span class="hljs-title">AutomaticKeepAliveClientMixin</span> </span>&#123;<br><span class="hljs-comment">//首页面所有数据的容器</span><br>  <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">dynamic</span>&gt; newsData;<br>  <span class="hljs-comment">//初始化频道数据的容器</span><br>  <span class="hljs-built_in">List</span>&lt;Channel&gt; channels;<br><br>  TabController _tabController;<br><br>  <span class="hljs-meta">@override</span><br>  initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    _initChannelData();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  dispose() &#123;<br>    _tabController.dispose();<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>  <span class="hljs-comment">//加载初始化json数据</span><br>  _initChannelData() &#123;<br>    channels = <span class="hljs-built_in">List</span>&lt;Channel&gt;();<br>    Future&lt;<span class="hljs-built_in">String</span>&gt; data =<br>        DefaultAssetBundle.of(context).loadString(<span class="hljs-string">&quot;assets/config/channel.json&quot;</span>);<br>    data.then((<span class="hljs-built_in">String</span> value) &#123;<br>      setState(() &#123;<br>        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">dynamic</span>&gt; data = json.decode(value);<br>        _tabController = TabController(<br>          vsync: <span class="hljs-keyword">this</span>,<br>          length: data.length,<br>        );<br>        data.forEach((tmp) &#123;<br>          channels.add(Channel.fromJson(tmp));<br>        &#125;);<br>      &#125;);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">//初始化标题指示条</span><br>  Widget _initChannelTitle() &#123;<br>    <span class="hljs-keyword">return</span> TabBar(<br>        controller: _tabController,<br>        indicatorColor: Colors.blue[<span class="hljs-number">100</span>],<br>        tabs: channels.map((Channel channel) &#123;<br>          <span class="hljs-keyword">return</span> Tab(<br>            text: channel.channelName,<br>          );<br>        &#125;).toList());<br>  &#125;<br><br>  <span class="hljs-comment">//初始化列表内容</span><br>  Widget _initChannelList() &#123;<br>    <span class="hljs-keyword">return</span> TabBarView(<br>      controller: _tabController,<br>      children: channels.map((Channel channel) &#123;<br>        <span class="hljs-keyword">return</span> NewsListWidget(channel: channel);<br>      &#125;).toList(),<br>    );<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> DefaultTabController(<br>      length: channels.length,<br>      child: Scaffold(<br>        appBar: AppBar(<br>          leading: Icon(Icons.title),<br>          title: Text(Strings.appTitle, style: TextStyle(color: Colors.white)),<br>          bottom: _initChannelTitle(),<br>          actions: &lt;Widget&gt;[<br>            IconButton(<br>              icon: Icon(Icons.assignment),<br>              onPressed: (() &#123;<br>                Navigator.push(<br>                  context,<br>                  MaterialPageRoute(builder: (context) =&gt; AboutPage()),<br>                );<br>              &#125;),<br>            ),<br>            IconButton(<br>                icon: Icon(Icons.autorenew),<br>                onPressed: (() &#123;<br>                  Constants.eventBus.fire(<br>                      Constants.currentTheme == Constants.dayTheme<br>                          ? ThemeEvent(Constants.nightTheme)<br>                          : ThemeEvent(Constants.dayTheme));<br>                &#125;))<br>          ],<br>        ),<br>        body: _initChannelList(),<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> wantKeepAlive =&gt; <span class="hljs-keyword">true</span>;<br>&#125;<br><br></code></pre>

<h3 id="列表页面"><a href="#列表页面" class="headerlink" title="列表页面"></a>列表页面</h3><pre class="highlight"><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_news/api/Apis.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_news/events/BeanEvent.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_news/constants/Constants.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_news/models/local/Channel.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_news/models/network/NewsList.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_news/pages/NewsDetailPage.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewsListWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> Channel channel;<br>  NewsListWidget(&#123;Key key, <span class="hljs-keyword">this</span>.channel&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  _NewsListState createState() =&gt; _NewsListState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_NewsListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">NewsListWidget</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">AutomaticKeepAliveClientMixin</span> </span>&#123;<br>  <span class="hljs-comment">//当前页</span><br>  <span class="hljs-built_in">int</span> _page = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//网络请求接口</span><br>  API$Neteast _api;<br>  <span class="hljs-comment">//该频道下的所有新闻数据</span><br>  <span class="hljs-built_in">List</span>&lt;News&gt; _datas;<br>  ScrollController _listController;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> wantKeepAlive =&gt; <span class="hljs-keyword">true</span>;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    _api = API$Neteast();<br>    _datas = [];<br>    _listController = ScrollController();<br>    _listController.addListener(() &#123;<br>      <span class="hljs-keyword">var</span> maxScroll = _listController.position.maxScrollExtent;<br>      <span class="hljs-keyword">var</span> pixels = _listController.position.pixels;<br>      <span class="hljs-keyword">if</span> (maxScroll == pixels) &#123;<br>        _page += <span class="hljs-number">20</span>;<br>        _getNewsList();<br>      &#125;<br>    &#125;);<br><br>    Constants.eventBus.<span class="hljs-keyword">on</span>&lt;BeanEvent&lt;NewsList&gt;&gt;().listen((event) &#123;<br>      <span class="hljs-keyword">if</span> (widget.channel.channelId == event.id) &#123;<br>        setState(() &#123;<br>          NewsList data = event.data;<br>          _datas.addAll(data.datas);<br>        &#125;);<br>      &#125;<br>    &#125;);<br>    _getNewsList();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    _listController.dispose();<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>  Future&lt;<span class="hljs-built_in">Null</span>&gt; _pullToRefresh() <span class="hljs-keyword">async</span> &#123;<br>    _page = <span class="hljs-number">0</span>;<br>    _datas.clear();<br>    _getNewsList();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br><br>  _getNewsList() &#123;<br>    _api.getNewsList(<br>        widget.channel.channelType, widget.channel.channelId, _page);<br>  &#125;<br><br>  _onItemClick(<span class="hljs-built_in">int</span> position, News data) &#123;<br>    <span class="hljs-keyword">if</span> (data.url == <span class="hljs-keyword">null</span> || data.url.isEmpty) &#123;<br>      Scaffold.of(context).showSnackBar(SnackBar(<br>        content: <span class="hljs-keyword">new</span> Text(<span class="hljs-string">&#x27;缺少新闻链接&#x27;</span>),<br>        duration: <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">1</span>),<br>      ));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      Navigator.of(context).push(MaterialPageRoute(<br>          builder: (ctx) =&gt; NewsDetailPage(<br>                postId: data.postid,<br>                url: data.url,<br>                title: <span class="hljs-string">&quot;&quot;</span>,<br>              )));<br>    &#125;<br>  &#125;<br><br>  Widget _renderRow(<span class="hljs-built_in">int</span> position) &#123;<br>    <span class="hljs-keyword">if</span> (position.isOdd) <span class="hljs-keyword">return</span> Divider();<br><br>    <span class="hljs-keyword">final</span> index = position ~/ <span class="hljs-number">2</span>;<br>    News data = _datas[index];<br><br>    <span class="hljs-keyword">return</span> Card(<br>      color: Colors.grey[<span class="hljs-number">250</span>],<br>      elevation: <span class="hljs-number">5.0</span>,<br>      child: InkWell(<br>        child: <span class="hljs-keyword">new</span> Column(<br>          crossAxisAlignment: CrossAxisAlignment.start,<br>          children: [<br>            Image.network(data.imgsrc, fit: BoxFit.fitWidth),<br>            Padding(<br>              padding: <span class="hljs-keyword">const</span> EdgeInsets.all(<span class="hljs-number">10.0</span>),<br>              child: Text(<br>                data.title,<br>                style: TextStyle(<br>                  fontSize: <span class="hljs-number">16.0</span>,<br>                  fontWeight: FontWeight.bold,<br>                ),<br>              ),<br>            ),<br>            Padding(<br>              padding: data.digest.isEmpty<br>                  ? <span class="hljs-keyword">const</span> EdgeInsets.all(<span class="hljs-number">0.0</span>)<br>                  : <span class="hljs-keyword">const</span> EdgeInsets.only(<br>                      left: <span class="hljs-number">10.0</span>, right: <span class="hljs-number">10.0</span>, bottom: <span class="hljs-number">10.0</span>),<br>              child: Text(<br>                data.digest,<br>                style: TextStyle(<br>                  fontSize: <span class="hljs-number">12.0</span>,<br>                ),<br>              ),<br>            ),<br>            Padding(<br>              padding: <span class="hljs-keyword">const</span> EdgeInsets.only(left: <span class="hljs-number">10.0</span>, right: <span class="hljs-number">10.0</span>),<br>              child: Text(<br>                <span class="hljs-string">&#x27;时间：<span class="hljs-subst">$&#123;data.ptime&#125;</span>&#x27;</span>,<br>                style: TextStyle(<br>                  fontSize: <span class="hljs-number">12.0</span>,<br>                ),<br>              ),<br>            ),<br>            Padding(<br>              padding:<br>                  <span class="hljs-keyword">const</span> EdgeInsets.only(left: <span class="hljs-number">10.0</span>, right: <span class="hljs-number">10.0</span>, bottom: <span class="hljs-number">10.0</span>),<br>              child: Text(<br>                <span class="hljs-string">&#x27;来源：<span class="hljs-subst">$&#123;data.source&#125;</span>&#x27;</span>,<br>                style: TextStyle(<br>                  fontSize: <span class="hljs-number">12.0</span>,<br>                ),<br>              ),<br>            )<br>          ],<br>        ),<br>        onTap: () &#123;<br>          _onItemClick(index, data);<br>        &#125;,<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">if</span> (_datas == <span class="hljs-keyword">null</span> || _datas.isEmpty) &#123;<br>      <span class="hljs-keyword">return</span> Center(child: CircularProgressIndicator());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      Widget listView = ListView.builder(<br>        padding: EdgeInsets.all(<span class="hljs-number">10.0</span>),<br>        itemCount: _datas.length * <span class="hljs-number">2</span>,<br>        itemBuilder: (context, i) =&gt; _renderRow(i),<br>        controller: _listController,<br>      );<br>      <span class="hljs-keyword">return</span> RefreshIndicator(child: listView, onRefresh: _pullToRefresh);<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre>
<h3 id="基于webView详情"><a href="#基于webView详情" class="headerlink" title="基于webView详情"></a>基于webView详情</h3><pre class="highlight"><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/cupertino.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_news/constants/constants.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_webview_plugin/flutter_webview_plugin.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewsDetailPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> url;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> title;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> postId;<br><br>  <span class="hljs-keyword">const</span> NewsDetailPage(&#123;Key key, <span class="hljs-keyword">this</span>.postId, <span class="hljs-keyword">this</span>.url, <span class="hljs-keyword">this</span>.title&#125;)<br>      : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; NewsDetailPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewsDetailPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">NewsDetailPage</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">bool</span> loaded = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-built_in">String</span> detailDataStr;<br>  <span class="hljs-keyword">final</span> flutterWebViewPlugin = FlutterWebviewPlugin();<br><br>  NewsDetailPageState(&#123;Key key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    flutterWebViewPlugin.onStateChanged.listen((state) &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;state: <span class="hljs-subst">$&#123;state.type&#125;</span>&quot;</span>);<br>      <span class="hljs-keyword">if</span> (state.type == WebViewState.finishLoad) &#123;<br>        setState(() &#123;<br>          loaded = <span class="hljs-keyword">true</span>;<br>        &#125;);<br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-built_in">List</span>&lt;Widget&gt; titleContent = [];<br>    titleContent.add(Text(<br>        widget.title == <span class="hljs-keyword">null</span> || widget.title.isEmpty<br>            ? Strings.newsDetail<br>            : widget.title,<br>        style: TextStyle(color: Colors.white)));<br>    <span class="hljs-keyword">if</span> (!loaded) &#123;<br>      titleContent.add(CupertinoActivityIndicator());<br>    &#125;<br>    titleContent.add(Container(width: <span class="hljs-number">50.0</span>));<br>    <span class="hljs-keyword">return</span> WebviewScaffold(<br>      url: widget.url,<br>      appBar: AppBar(<br>        title: Row(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: titleContent,<br>        ),<br>        iconTheme: IconThemeData(color: Colors.white),<br>      ),<br>      withZoom: <span class="hljs-keyword">false</span>,<br>      withLocalStorage: <span class="hljs-keyword">true</span>,<br>      withJavascript: <span class="hljs-keyword">true</span>,<br>    );<br>  &#125;<br>&#125;<br><br></code></pre>
<h3 id="请求及数据"><a href="#请求及数据" class="headerlink" title="请求及数据"></a>请求及数据</h3><pre class="highlight"><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_news/constants/Constants.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:http/http.dart&#x27;</span> <span class="hljs-keyword">as</span> http;<br><span class="hljs-comment">// 使用网上公共接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetWork</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> _debug = <span class="hljs-keyword">true</span>;<br>  <span class="hljs-comment">//网易新闻的host</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> NETEAST_HOST = <span class="hljs-string">&quot;https://c.m.163.com/&quot;</span>;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> getHost(<span class="hljs-built_in">int</span> type) &#123;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>      <span class="hljs-keyword">case</span> Constants.TYPE_NET_NETEASE_NEWS:<br>        <span class="hljs-keyword">return</span> NETEAST_HOST;<br><br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/* 基础GET请求 */</span><br>  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">get</span>(<span class="hljs-built_in">String</span> url, &#123;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; params&#125;) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">if</span> (params != <span class="hljs-keyword">null</span> &amp;&amp; params.isNotEmpty) &#123;<br>      <span class="hljs-built_in">StringBuffer</span> sb = <span class="hljs-built_in">StringBuffer</span>(<span class="hljs-string">&quot;?&quot;</span>);<br>      params.forEach((key, value) &#123;<br>        sb.write(<span class="hljs-string">&quot;<span class="hljs-subst">$key</span>&quot;</span> + <span class="hljs-string">&quot;=&quot;</span> + <span class="hljs-string">&quot;<span class="hljs-subst">$value</span>&quot;</span> + <span class="hljs-string">&quot;&amp;&quot;</span>);<br>      &#125;);<br>      <span class="hljs-built_in">String</span> paramStr = sb.toString();<br>      paramStr = paramStr.substring(<span class="hljs-number">0</span>, paramStr.length - <span class="hljs-number">1</span>);<br>      url += paramStr;<br>    &#125;<br>    http.Response res = <span class="hljs-keyword">await</span> http.<span class="hljs-keyword">get</span>(url, headers: getCommonHeader());<br>    <span class="hljs-keyword">if</span> (_debug) &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;发起Get请求_____<span class="hljs-subst">$url</span>|________________<span class="hljs-subst">$&#123;res.body&#125;</span>|&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.body;<br>  &#125;<br><br><span class="hljs-comment">/* 基础POST请求 */</span><br>  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">String</span>&gt; post(<span class="hljs-built_in">String</span> url, &#123;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; params&#125;) <span class="hljs-keyword">async</span> &#123;<br>    http.Response res =<br>        <span class="hljs-keyword">await</span> http.post(url, body: params, headers: getCommonHeader());<br>    <span class="hljs-keyword">if</span> (_debug) &#123;<br>      <span class="hljs-built_in">print</span>(<br>          <span class="hljs-string">&#x27;|发起Post请求|_______|<span class="hljs-subst">$url</span>|______|<span class="hljs-subst">$&#123;params.toString()&#125;</span>|________|<span class="hljs-subst">$&#123;res.body&#125;</span>|&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.body;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; getCommonHeader() &#123;<br>    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; header = <span class="hljs-built_in">Map</span>();<br>    header[<span class="hljs-string">&#x27;User-Agent&#x27;</span>] =<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36&#x27;</span>;<br>    <span class="hljs-keyword">return</span> header;<br>  &#125;<br>&#125;<br><br></code></pre>
<p><a href="https://github.com/lizil-git/flutter_news.git">源码获取地址</a></p>
]]></content>
      <categories>
        <category>拓展学习</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2数据双向绑定原理</title>
    <url>/posts/5b80f5a6.html</url>
    <content><![CDATA[<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// vue2中会对数据在初始化事使用的是Object.defineProperty，遍历对象将对象的每一个属性进行劫持。</span><br><span class="hljs-comment">// vue2响应式弊端：</span><br><span class="hljs-comment">// 响应化过程需要递归遍历，消耗较大 </span><br><span class="hljs-comment">// 新加或删除属性无法监听</span><br><span class="hljs-comment">// 数组响应化需要额外实现 </span><br><span class="hljs-comment">// Map、Set、Class等无法响应式 </span><br><span class="hljs-comment">// 修改语法有限制</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span>(<span class="hljs-params">options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">__init</span>(options);<br>&#125;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__init</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span> = options;<br>  <span class="hljs-comment">// 假设这里就是一个 el， 已经 querySelector 的</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span> = options.<span class="hljs-property">el</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span> = options.<span class="hljs-property">data</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$methods</span> = options.<span class="hljs-property">methods</span>;<br>  <span class="hljs-title function_">proxy</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>);<br>  <span class="hljs-title function_">observer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>);<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Compiler</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><span class="hljs-comment">// 将this.$data改变成this</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-params">target, data</span>) &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, &#123;<br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> data[key];<br>      &#125;,<br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>        <span class="hljs-comment">// 考虑 NaN 的情况</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isSameVal</span>(data[key], newVal)) &#123;<br>          data[key] = newVal;<br>        &#125;<br>      &#125;<br>    &#125;)<br>  &#125;)<br>&#125;<br><span class="hljs-comment">// Observer来监听自己的model数据变化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">observer</span>(<span class="hljs-params">data</span>) &#123; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(data) &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(data);<br>  &#125;<br>  <span class="hljs-title function_">walk</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">if</span> (data &amp;&amp; <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">defineReactive</span>(data, key, data[key]));<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 把每一个 data 里面的数据，收集起来。</span><br>  <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, value</span>) &#123;<br>    <span class="hljs-keyword">let</span> that = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value);<br>    <span class="hljs-keyword">let</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>();<br>    <span class="hljs-comment">// Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</span><br>    <span class="hljs-comment">// Object.defineProperty(obj, prop, descriptor)</span><br>    <span class="hljs-comment">// obj 要定义属性的对象。prop 要定义或修改的属性的名称或 Symbol。descriptor 要定义或修改的属性描述符。</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 4. 对于 num 来说，要执行这一句。</span><br>        <span class="hljs-comment">// 5. num 中的 dep, 就有了这个 watcher</span><br>        <span class="hljs-comment">// dep: [watcher, watcher ]</span><br>        <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> &amp;&amp; dep.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>);<br>        <span class="hljs-keyword">return</span> value<br>      &#125;,<br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isSameVal</span>(value, newVal)) &#123;<br>          <span class="hljs-comment">// 赋值进来的新值，是没有响应式的，所以再 walk 一次，给到响应式。</span><br>          value = newVal;<br>          that.<span class="hljs-title function_">walk</span>(newVal);<br>          <span class="hljs-comment">// 重新set时，通知更新</span><br>          <span class="hljs-comment">// 6.</span><br>          dep.<span class="hljs-title function_">notify</span>();<br>        &#125;<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 数据改变，视图才会更新。需要去观察</span><br><span class="hljs-comment">// 1. new Watcher( vm, &#x27;num&#x27;, () =&gt; &#123;更新视图上的num显示&#125; )</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, key, cb</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm; <span class="hljs-comment">// VUE 的一个实例</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb;<br>    <br>    <span class="hljs-comment">// 2. 此时 Dep.target 作为一个全局变量理解，放的就是这个 watcher;</span><br>    <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 3. 一旦进行了这一句赋值，是不是就触发了这个值的 getter 函数。</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">__old</span> = vm[key];<br>    <span class="hljs-comment">// 把 Dep.target 删除。</span><br>    <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 8. 执行所有的 cb 函数。</span><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> newVal = <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span>];<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isSameVal</span>(newVal, <span class="hljs-variable language_">this</span>.<span class="hljs-property">__old</span>)) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cb</span>(newVal);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 每一个数据都要有一个 dep 的依赖</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">watchers</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  &#125;<br>  <br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">watcher</span>) &#123;<br>    <span class="hljs-keyword">if</span> (watcher &amp;&amp; watcher.<span class="hljs-property">update</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">watchers</span>.<span class="hljs-title function_">add</span>(watcher);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 7. 让所有的 watcher 执行 update 方法。</span><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">watchers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">watc</span> =&gt;</span> watc.<span class="hljs-title function_">update</span>())<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 解析器 用于解析所有标签的节点对里面的vue的指令进行解析 详细可以看vue项目中的compiler文件夹</span><br><span class="hljs-comment">// 最终利用`Watcher`搭起`Observer`和`Compile`之间的通信桥梁</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compiler</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span> = vm.<span class="hljs-property">$el</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">methods</span> = vm.<span class="hljs-property">$methods</span>;<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(vm.<span class="hljs-property">$el</span>);<br>  &#125;<br>  <span class="hljs-comment">// 这里是递归编译 #app 下面的所有的节点内容；</span><br>  <span class="hljs-title function_">compile</span>(<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-keyword">let</span> childNodes = el.<span class="hljs-property">childNodes</span>;<br>    <span class="hljs-comment">// 类数组</span><br>    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(childNodes).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 判断如果是文本节点</span><br>      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeType</span> === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileText</span>(node)<br>      &#125;<br>      <span class="hljs-comment">// 如果是元素节点</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileElement</span>(node)<br>      &#125;<br>      <span class="hljs-comment">// 如果还有子节点，就递归下去。</span><br>      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">childNodes</span> &amp;&amp; node.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(node);<br>      <span class="hljs-comment">// ...</span><br>    &#125;)<br>  &#125;<br>  <br>  <span class="hljs-title function_">compileText</span>(<span class="hljs-params">node</span>) &#123;<br>    <span class="hljs-comment">// 匹配出来 &#123;&#123;massage&#125;&#125;</span><br>    <span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/</span>;<br>    <span class="hljs-keyword">let</span> value = node.<span class="hljs-property">textContent</span>;<br>    <span class="hljs-keyword">if</span> (reg.<span class="hljs-title function_">test</span>(value)) &#123;<br>      <span class="hljs-keyword">let</span> key = <span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>.<span class="hljs-title function_">trim</span>()<br>      <span class="hljs-comment">// 开始时赋值。</span><br>      node.<span class="hljs-property">textContent</span> = value.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>[key]);<br>      <span class="hljs-comment">// 添加观察者</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, key, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 数据改变时的更新</span><br>        node.<span class="hljs-property">textContent</span> = val;<br>      &#125;)<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-title function_">compileElement</span>(<span class="hljs-params">node</span>) &#123;<br>    <span class="hljs-comment">// 简化，只做匹配 v-on 和 v-model 的匹配</span><br>    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">attributes</span>.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(node.<span class="hljs-property">attributes</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">attr</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> attrName = attr.<span class="hljs-property">name</span>;<br>        <span class="hljs-keyword">if</span> (attrName.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;v-&#x27;</span>)) &#123;<br>          <span class="hljs-comment">// v- 指令匹配成功，可能是 v-on:click 或者 v-model</span><br>          attrName = attrName.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;:&#x27;</span>) &gt; -<span class="hljs-number">1</span> ? attrName.<span class="hljs-title function_">substr</span>(<span class="hljs-number">5</span>) : attrName.<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>)<br>          <span class="hljs-keyword">let</span> key = attr.<span class="hljs-property">value</span>;<br>          <span class="hljs-comment">// </span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">update</span>(node, key, attrName, <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>[key])<br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-title function_">update</span>(<span class="hljs-params">node, key, attrName, value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (attrName === <span class="hljs-string">&#x27;model&#x27;</span>) &#123;<br>      node.<span class="hljs-property">value</span> = value;<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, key, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> node.<span class="hljs-property">value</span> = val);<br>      node.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>[key] = node.<span class="hljs-property">value</span>;<br>      &#125;)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (attrName === <span class="hljs-string">&#x27;click&#x27;</span>) &#123;<br>      node.<span class="hljs-title function_">addEventListener</span>(attrName, <span class="hljs-variable language_">this</span>.<span class="hljs-property">methods</span>[key].<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>))<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isSameVal</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a === b || (<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(a) &amp;&amp; <span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(b))<br>&#125;<br></code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/28427234/1655177269004-81b93a81-0a94-4f3f-9007-06b06c190304.png#averageHue=%23f7f6f4&clientId=u2a16734d-d6b3-4&from=paste&height=1520&id=u70f6aff3&name=image.png&originHeight=3039&originWidth=1200&originalType=binary&ratio=1&rotation=0&showTitle=false&size=269919&status=done&style=none&taskId=u8e8d00a1-549d-4be5-a535-bbfc57f2bc3&title=&width=600" alt="image.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2022/png/28427234/1655177269004-81b93a81-0a94-4f3f-9007-06b06c190304.png#averageHue=%23f7f6f4&clientId=u2a16734d-d6b3-4&from=paste&height=1520&id=u70f6aff3&name=image.png&originHeight=3039&originWidth=1200&originalType=binary&ratio=1&rotation=0&showTitle=false&size=269919&status=done&style=none&taskId=u8e8d00a1-549d-4be5-a535-bbfc57f2bc3&title=&width=600" class="lozad post-image"></p>
]]></content>
      <categories>
        <category>源码探索</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3数据双向绑定原理</title>
    <url>/posts/fe0b65a8.html</url>
    <content><![CDATA[<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 因为vue3中不再是将数据定义到data中就可以实现响应式,而是使用reactive或ref</span><br><span class="hljs-comment">// WeakMap 的 key 只能是 Object 类型。</span><br><span class="hljs-keyword">let</span> targetMap = <span class="hljs-title class_">WeakMap</span>();<br><span class="hljs-keyword">let</span> activeEffect;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &#123;</span><br><span class="hljs-comment"> *    target:&#123;</span><br><span class="hljs-comment"> *      key: [ReactiveEffect,ReactiveEffect,....]</span><br><span class="hljs-comment"> *    &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 收集依赖</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-comment">// 判断该值是否收集,未收集就添加</span><br>    <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);<br>    <span class="hljs-keyword">if</span> (!depsMap) targetMap.<span class="hljs-title function_">set</span>(depsMap, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()));<br>    <span class="hljs-comment">// 判断depsMap 中有没有key</span><br>    <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key);<br>    <span class="hljs-keyword">if</span> (!dep) depsMap.<span class="hljs-title function_">set</span>(key, (dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()));<br>    <span class="hljs-title function_">trackEffect</span>(dep);<br>&#125;<br><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">trackEffect</span>(<span class="hljs-params">dep</span>) &#123;<br>    <span class="hljs-comment">// 相当于 vue2中的, Dep.target &amp;&amp; dep.add(Dep.target)</span><br>    <span class="hljs-keyword">if</span> (dep.<span class="hljs-title function_">has</span>(activeEffect)) dep.<span class="hljs-title function_">add</span>(activeEffect)<br>&#125;<br><span class="hljs-comment">// 触发</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);<br>    <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// effect 上面肯定有一个 run 方法。</span><br>    depsMap.<span class="hljs-title function_">get</span>(key).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> effect &amp;&amp; effect.<span class="hljs-title function_">run</span>())<br>&#125;<br><br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment">备注1: Reflect</span><br><span class="hljs-comment">Reflect是一个内建的对象，用来提供方法去拦截JavaScript的操作。Reflect不是一个函数对象，所以它是不可构造的，也就是说它不是一个构造器，你不能通过`new`操作符去新建或者将其作为一个函数去调用Reflect对象。Reflect的所有属性和方法都是静态的。</span><br><span class="hljs-comment">1.现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。</span><br><span class="hljs-comment">2.修改某些Object方法的返回结果，让其变得更规范化。如Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。让Object操作都变成函数行为。</span><br><span class="hljs-comment">3.Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//进行判断是否是对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">return</span> data &amp;&amp; <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;object&#x27;</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(data)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</span><br>    <span class="hljs-comment">// https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-proxy.md  Proxy 支持的拦截操作，一共 13 种</span><br>    <span class="hljs-comment">// 简化createReactiveObject</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>        <span class="hljs-comment">// Reflect.get()方法与从 对象 (target[propertyKey]) 中读取属性类似，但它是通过一个函数执行来操作的。</span><br>        <span class="hljs-comment">// 因备注1.1,在继承可能会出现问题 因此这里不使用target[key]</span><br>        <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, reactiver</span>) &#123;<br>            <span class="hljs-keyword">const</span> ret = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, reactiver);<br>            <span class="hljs-title function_">track</span>(target, key);<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">isObject</span>(ret) ? <span class="hljs-title function_">reactive</span>(ret) : ret;<br>        &#125;,<br>        <span class="hljs-comment">// Reflect.set() 工作方式就像在一个对象上设置一个属性。</span><br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, reactiver</span>) &#123;<br>            <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, reactiver);<br>            <span class="hljs-title function_">trigger</span>(target, key);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;,<br>        <span class="hljs-comment">// 拦截delete操作，如果这个方法抛出错误，或者返回false，则当前属性就无法被delete命令删除</span><br>        <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, key</span>) &#123;<br>            <span class="hljs-title function_">trigger</span>(target, key);<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(target, key);<br>        &#125;,<br>        <span class="hljs-comment">//拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效，典型的就是in操作符</span><br>        <span class="hljs-comment">//如果原对象不可配置或者禁止扩展，这时has拦截会报错。</span><br>        <span class="hljs-comment">//值得注意的是，has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。</span><br>        <span class="hljs-title function_">has</span>(<span class="hljs-params">target, key</span>) &#123;<br>            <span class="hljs-title function_">track</span>(target, key);<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, key);<br>        &#125;,<br>        <span class="hljs-comment">//拦截对象自身属性的读取操作，具体拦截以下操作：object.getOwnPropertyNames(), object.getOwnPropertySymbols(), object.keys()</span><br>        <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params">target, key</span>) &#123;<br>            <span class="hljs-title function_">track</span>(target, key);<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(target, key)<br>        &#125;<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ref</span>(<span class="hljs-params">init</span>) &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefImpl</span> &#123;<br>        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">init</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">__value</span> = init;<br>        &#125;<br>        <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>            <span class="hljs-comment">// trackRefValue源码方法,为了方便现全部使用track</span><br>            <span class="hljs-title function_">track</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">__value</span>;<br>        &#125;<br>        <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newValue</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">__value</span> = newValue;<br>            <span class="hljs-title function_">trigger</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefImpl</span>(init)<br>&#125;<br><br><br><span class="hljs-comment">// 在定义一个 effect 的函数中，第一个参数是一个函数；</span><br><span class="hljs-comment">// 如果这个函数中，有使用 ref/reactive </span><br><span class="hljs-comment">// effect(() =&gt; &#123;</span><br><span class="hljs-comment">//    console.log(num.value)</span><br><span class="hljs-comment">// &#125;)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn, options = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">let</span> __effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(fn);<br>    <span class="hljs-keyword">if</span> (!options.<span class="hljs-property">lazy</span>) &#123;<br>        __effect.<span class="hljs-title function_">run</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> __effect;<br>&#125;<br><br><span class="hljs-comment">// 计算属性监听</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">computed</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-comment">// 只考虑函数的情况</span><br>    <span class="hljs-keyword">let</span> __computed;<br>    <span class="hljs-keyword">const</span> e = <span class="hljs-title function_">effect</span>(fn, &#123; <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span> &#125;);<br>    __computed = &#123;<br>        <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>            <span class="hljs-keyword">return</span> e.<span class="hljs-title function_">run</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> __computed;<br><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mount</span>(<span class="hljs-params">instance, el</span>) &#123;<br>    <span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        instance.<span class="hljs-property">$data</span> &amp;&amp; <span class="hljs-title function_">update</span>(instance, el);<br>    &#125;)<br>    instance.<span class="hljs-property">$data</span> = instance.<span class="hljs-title function_">setup</span>()<br>    <span class="hljs-title function_">update</span>(instance, el);<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">instance, el</span>) &#123;<br>        el.<span class="hljs-property">innerHTML</span> = instance.<span class="hljs-title function_">render</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fn</span> = fn;<br>    &#125;<br>    <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        activeEffect = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fn</span>();<br>    &#125;<br>&#125;<br></code></pre>
<h2 id="设计大纲"><a href="#设计大纲" class="headerlink" title="设计大纲"></a>设计大纲</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/28427234/1655262364892-868dfc78-aed5-42de-8997-9581666eeae0.png#averageHue=%23f9f8f8&clientId=u8c4af0e2-d2a6-4&from=paste&height=247&id=uea64084a&name=image.png&originHeight=494&originWidth=1454&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111803&status=done&style=none&taskId=u59193ea8-c098-4617-8f42-8c5969af80d&title=&width=727" alt="image.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2022/png/28427234/1655262364892-868dfc78-aed5-42de-8997-9581666eeae0.png#averageHue=%23f9f8f8&clientId=u8c4af0e2-d2a6-4&from=paste&height=247&id=uea64084a&name=image.png&originHeight=494&originWidth=1454&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111803&status=done&style=none&taskId=u59193ea8-c098-4617-8f42-8c5969af80d&title=&width=727" class="lozad post-image"></p>
<h2 id="Proxy捕获器"><a href="#Proxy捕获器" class="headerlink" title="Proxy捕获器"></a>Proxy捕获器</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/28427234/1655274755418-3d91a945-516c-4bfd-9f1f-41736b4c4e8d.png#averageHue=%23f9f9f9&clientId=u337650ff-b894-4&from=paste&height=869&id=u170247bc&name=image.png&originHeight=1738&originWidth=1420&originalType=binary&ratio=1&rotation=0&showTitle=false&size=270174&status=done&style=none&taskId=u1b2c819b-c3ee-4ffa-993f-38e438651ef&title=&width=710" alt="image.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2022/png/28427234/1655274755418-3d91a945-516c-4bfd-9f1f-41736b4c4e8d.png#averageHue=%23f9f9f9&clientId=u337650ff-b894-4&from=paste&height=869&id=u170247bc&name=image.png&originHeight=1738&originWidth=1420&originalType=binary&ratio=1&rotation=0&showTitle=false&size=270174&status=done&style=none&taskId=u1b2c819b-c3ee-4ffa-993f-38e438651ef&title=&width=710" class="lozad post-image"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/28427234/1655274784234-e66e45cc-6f7f-415d-a1e9-9383b3a0f792.png#averageHue=%23fbfafa&clientId=u337650ff-b894-4&from=paste&height=513&id=u9c60fa5e&name=image.png&originHeight=1026&originWidth=1478&originalType=binary&ratio=1&rotation=0&showTitle=false&size=147484&status=done&style=none&taskId=u3266ed5d-e854-4f48-8160-1aa00086721&title=&width=739" alt="image.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2022/png/28427234/1655274784234-e66e45cc-6f7f-415d-a1e9-9383b3a0f792.png#averageHue=%23fbfafa&clientId=u337650ff-b894-4&from=paste&height=513&id=u9c60fa5e&name=image.png&originHeight=1026&originWidth=1478&originalType=binary&ratio=1&rotation=0&showTitle=false&size=147484&status=done&style=none&taskId=u3266ed5d-e854-4f48-8160-1aa00086721&title=&width=739" class="lozad post-image"></p>
]]></content>
      <categories>
        <category>源码探索</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>发布—订阅模式</title>
    <url>/posts/85d98369.html</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>第一点说明发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。 比如，我们可以订阅 ajax 请求的 error、succ 等事件。或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。<br>第二点说明发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调 用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼 此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。</p>
<h2 id="JavaScript中的运用"><a href="#JavaScript中的运用" class="headerlink" title="JavaScript中的运用"></a>JavaScript中的运用</h2><p>JavaScript 本身也是一门基于事件驱动的语言，所以发布—订阅模式的运用相当广泛，如在DOM上绑定事件就是对这种模式的运用，我们只需要将事件绑定到对应DOM上后，我们将不需要关注用户何时去触发，而是关注触发后的动作。在事件触发后就DOM将会通知执行我们绑定的事件。我们常用的vue框架也是使用该模式实现了对数据的双向绑定，在使用JavaScript逻辑对需要监听的数据进行改变时，会触发改变页面显示的解析方法，同理，在页面上对监听的数据进行改变是也会去改变对应的JavaScript里的变量值，详细分析点击<a href="https://www.liyueer.cn/posts/5b80f5a6.html">vue2中对发布-订阅模式的运用</a> 和 <a href="https://www.liyueer.cn/posts/fe0b65a8.html">vue3中对发布-订阅模式的运用</a>。</p>
<h2 id="必须先订阅再发布吗？"><a href="#必须先订阅再发布吗？" class="headerlink" title="必须先订阅再发布吗？"></a>必须先订阅再发布吗？</h2><p>上面说到该模式广泛应用于异步编程中，对于异步里无法判断触发时间，因此会出现还未加载执行完毕订阅相关代码时发布代码执行了，造成发布消息的代码成为无效代码。对于这种情况必须编写该模块时进行判断。如创建一个存储离线事件的堆栈，当事件发布的时候，如果此时还 没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将被 存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 对于自定义对象，实现发布-订阅模式</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Event</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-title class_">Event</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> _default = <span class="hljs-string">&#x27;default&#x27;</span>;<br>    <span class="hljs-title class_">Event</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> _listen = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">let</span> _trigger = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">let</span> _remove = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">let</span> _shift = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>;<br>        <span class="hljs-keyword">let</span> _unshift = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">unshift</span>;<br>        <span class="hljs-keyword">let</span> namespaceCache = &#123;&#125;; <span class="hljs-comment">// 使用该对象将命名空间缓存起来</span><br>        <span class="hljs-keyword">let</span> _create = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 用户当用户触发是进行事件遍历,而进行对以订阅者进行发布发布</span><br>        each = <span class="hljs-keyword">function</span> (<span class="hljs-params">ary, fn</span>) &#123;<br>            <span class="hljs-keyword">let</span> ret = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ary.<span class="hljs-property">length</span>; i++) &#123;<br>                <span class="hljs-keyword">let</span> n = ary[i];<br>                ret = fn.<span class="hljs-title function_">call</span>(n, i, n);<br>            &#125;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;;<br>        <span class="hljs-comment">// 添加监听</span><br>        _listen = <span class="hljs-keyword">function</span> (<span class="hljs-params">key, fn, cache</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache,<span class="hljs-string">&quot;输出cache&quot;</span>)<br>            <span class="hljs-keyword">if</span> (!cache[key]) cache[key] = [];<br>            cache[key].<span class="hljs-title function_">push</span>(fn);<br>        &#125;;<br>        <span class="hljs-comment">// 触发</span><br>        _trigger = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;...<span class="hljs-variable language_">arguments</span>&#125;,<span class="hljs-string">&#x27;argumentsargumentsarguments&#x27;</span>)<br>            <span class="hljs-keyword">let</span> cache = _shift.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache,<span class="hljs-string">&#x27;cachecachecachecache&#x27;</span>)<br>            <span class="hljs-keyword">let</span> key = _shift.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>            <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br>            <span class="hljs-keyword">let</span> _self = <span class="hljs-variable language_">this</span>;<br>            <span class="hljs-keyword">let</span> stack = cache[key];<br>            <span class="hljs-keyword">if</span> (!stack || !stack.<span class="hljs-property">length</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">each</span>(stack, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">apply</span>(_self, args)<br>            &#125;)<br>        &#125;;<br>        <span class="hljs-comment">// 如果已经创建该命名空间则返回该命名空间的发布订阅对象,否则将使用ret创建的新对象</span><br>        _create = <span class="hljs-keyword">function</span> (<span class="hljs-params">namespace</span>) &#123;<br>            <span class="hljs-keyword">var</span> namespace = namespace || _default;<br>            <span class="hljs-keyword">let</span> cache = &#123;&#125;;<br>            <span class="hljs-keyword">let</span> offlineStack = [];<br>            <span class="hljs-keyword">let</span> ret = &#123;<br>                <span class="hljs-attr">listen</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">key, fn, last</span>) &#123;<br>                    <span class="hljs-title function_">_listen</span>(key, fn, cache);<br>                    <span class="hljs-keyword">if</span> (offlineStack === <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (last === <span class="hljs-string">&quot;last&quot;</span>) &#123;<br>                        offlineStack.<span class="hljs-property">length</span> &amp;&amp; offlineStack.<span class="hljs-title function_">pop</span>();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-title function_">each</span>(offlineStack, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>                            <span class="hljs-title function_">this</span>();<br>                        &#125;);<br>                    &#125;<br>                    offlineStack = <span class="hljs-literal">null</span>;<br>                &#125;,<br>                <span class="hljs-attr">one</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">key, fn, last</span>) &#123;<br>                    <span class="hljs-title function_">_remove</span>(key, cache);<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listen</span>(key, fn, last);<br>                &#125;,<br>                <span class="hljs-attr">remove</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">key, fn</span>) &#123;<br>                    <span class="hljs-title function_">_remove</span>(key, cache, fn);<br>                &#125;,<br>                <span class="hljs-attr">trigger</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                    <span class="hljs-keyword">let</span> fn = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br>                    <span class="hljs-keyword">let</span> _self = <span class="hljs-variable language_">this</span>;<br>                    _unshift.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, cache);<br>                    args = <span class="hljs-variable language_">arguments</span>;<br>                    fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                        <span class="hljs-keyword">return</span> _trigger.<span class="hljs-title function_">apply</span>(_self, args);<br>                    &#125;;<br>                    <span class="hljs-keyword">if</span> (offlineStack) &#123;<br>                        <span class="hljs-keyword">return</span> offlineStack.<span class="hljs-title function_">push</span>(fn);<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>()<br>                &#125;<br>            &#125;;<br>            <span class="hljs-comment">// 如果命名空间在缓存中,则使用已经存起来的对象,如果不存在则使用_default的命名空间</span><br>            <span class="hljs-keyword">return</span> namespaceCache[namespace] ? namespaceCache[namespace] : namespaceCache[namespace] = ret;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">create</span>: _create, <span class="hljs-comment">// 使用命名空间形式</span><br>            <span class="hljs-attr">one</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">key, fn, last</span>) &#123;<br>                <span class="hljs-keyword">let</span> event = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">create</span>();<br>                event.<span class="hljs-title function_">one</span>(key, fn, last);<br>            &#125;,<br>            <span class="hljs-attr">remove</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">key, fn</span>) &#123;<br>                <span class="hljs-keyword">let</span> event = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">create</span>();<br>                event.<span class="hljs-title function_">remove</span>(key, fn);<br>            &#125;,<br>            <span class="hljs-attr">listen</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">key, fn, last</span>) &#123;<br>                <span class="hljs-keyword">let</span> event = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">create</span>();<br>                event.<span class="hljs-title function_">listen</span>(key, fn, last)<br>            &#125;,<br>            <span class="hljs-attr">trigger</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">let</span> event = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">create</span>();<br>                event.<span class="hljs-property">trigger</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>)<br>            &#125;<br>        &#125;<br>    &#125;();<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Event</span>;<br>&#125;)();<br><span class="hljs-comment">// 如果命名空间在缓存中,则使用已经存起来的对象,如果不存在则使用_default的命名空间</span><br><br><span class="hljs-title class_">Event</span>.<span class="hljs-title function_">trigger</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-title class_">Event</span>.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>&#125;)<br><span class="hljs-title class_">Event</span>.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>&#125;)<br><span class="hljs-comment">// 使用命名空间=================================</span><br><span class="hljs-title class_">Event</span>.<span class="hljs-title function_">create</span>(<span class="hljs-string">&#x27;namespace1&#x27;</span>).<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">// 输出:1</span><br>&#125;);<br><span class="hljs-title class_">Event</span>.<span class="hljs-title function_">create</span>(<span class="hljs-string">&#x27;namespace1&#x27;</span>).<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,<span class="hljs-string">&#x27;大萨达萨达&#x27;</span>);  <span class="hljs-comment">// 输出:1</span><br>&#125;);<br><span class="hljs-title class_">Event</span>.<span class="hljs-title function_">create</span>(<span class="hljs-string">&#x27;namespace1&#x27;</span>).<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,<span class="hljs-string">&#x27;禅道上的就后端数据肯定会&#x27;</span>);  <span class="hljs-comment">// 输出:1</span><br>&#125;);<br><span class="hljs-title class_">Event</span>.<span class="hljs-title function_">create</span>(<span class="hljs-string">&#x27;namespace2&#x27;</span>).<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">// 输出:2</span><br>&#125;);<br><span class="hljs-title class_">Event</span>.<span class="hljs-title function_">create</span>(<span class="hljs-string">&#x27;namespace1&#x27;</span>).<span class="hljs-title function_">trigger</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-number">123</span>);<br><br></code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>发布—订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常 广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。但是不能过度使用该模式，因此在创建后，订阅模式代码肯定会占用一定内存，不论是否有消息进行发布。而且该模式会弱化对象之间的关系，将会使代码可读性降低，进而导致程序难以跟踪维护和理解。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>包管理器命令</title>
    <url>/posts/187a3295.html</url>
    <content><![CDATA[<p>记录一下各种开发中能够用到的工具命令,方便快速查询到一些常用命令</p>
<h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><div class="post-note note-info"><p>设置包下载源：yarn config set npmRegistryServer<br>查看当前包下载源：yarn config get registry<br>自动安装最新版本，会覆盖指定版本号：yarn add [package]<br>一次性添加多个包：yarn add [package] [package] [package]<br>添加指定版本的包：yarn add [package]@[version]<br>安装某个tag：yarn add [package]@[tag]<br>添加到devDependencies：–dev，-D<br>添加到peerDependencies：–peer， -P<br>添加到optionalDependencies：–optional，-O<br>升级到最新版本：yarn upgrade [package]<br>升级到指定版本：yarn upgrade [package]@[version]<br>升级到指定tag：yarn upgrade [package]@[tag]<br>移除包：yarn remove [package]<br>安装所有依赖： yarn，yarn install<br>安装一个包的单一版本：yarn install –flat<br>强制重新下载所有包：yarn install –force<br>只安装生产环境依赖：yarn install –production<br>可以用来查看某个模块的最新版本信息：yarn info [package]<br>列出已缓存的每个包：yarn cache list<br>返回全局缓存位置：yarn cache dir<br>清除缓存：yarn cache clean </p></div>
<h2 id="yrm"><a href="#yrm" class="headerlink" title="yrm"></a>yrm</h2><div class="post-note note-info"><p>yrm 是一个 yarn源管理器，可以快速地在源间切换<br>查看已有源：yrm ls<br>使用xxx镜像源： yrm use xxx<br>增加一个源：yrm add &lt;源名称&gt; &lt;源地址&gt;<br>删除源: yrm del &lt;源名称&gt;<br>测试xx镜像源访问速度：yrm test taobao<br>查看npm当前镜像源：npm config get registry<br>查看yarn当前镜像源：yarn config get registry </p></div>
<h2 id="npm、cnpm"><a href="#npm、cnpm" class="headerlink" title="npm、cnpm"></a>npm、cnpm</h2><div class="post-note note-info"><p>设置包下载源：npm config set registry<br>获取包下载源：npm config get registry<br>安装所有依赖: npm install，npm i<br>安装到全局目录里：-g，–global<br>添加到dependencies：-S，–save<br>添加到devDependencies-D，–save-dev<br>卸载依赖，不卸载package.json的对应信息：npm uninstall [package]<br>卸载全局模块：npm uninstall [package] -g<br>卸载依赖，不卸载package.json中的dependencies对应信息：npm uninstall [package] –save<br>卸载依赖，同时package.json中的devDependencies对应信息：npm uninstall [package] –save-dev<br>更新最新版本:npm update [package]<br>更新到指定版本号:npm update [package]@[version]<br>更新到最后一个新版本:npm install [package]@latest<br>查看项目中模块所在的目录：npm root<br>查看全局安装的模块所在目录：npm root -g<br>查看本地已安装模块的清单列表:npm list， npm ls<br>查看某个包对于各种包的依赖关系：npm view [version] dependencies<br>查看[package]最新的版本号：npm view [package] version<br>查看所有[package]历史版本号：npm view [package] versions<br>查看最新的[package]版本的信息：npm view [package]<br>查看[package]的详细信息：npm info [package]<br>查看本地已安装的[package]的详细信息：npm list [package] ，npm ls [package]<br> 查看[package]包的来源地址：npm view [package] repository.url<br>清除npm的缓存：npm cache clean<br>清除项目中没有被使用的包：npm prune<br>检查模块是否已经过时：npm outdated<br>会打开默认浏览器跳转到github中[package]的页面：npm repo [package]<br>会打开默认浏览器跳转到github中jquery的README.MD文件信息：npm docs [package]<br>会打开默认浏览器跳转到github中jquery的主页：npm home [package]</p></div>
<h2 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h2><div class="post-note note-info"><p>nrm can help you easy and fast switch between different npm registries（nrm可以帮助您在不同的npm镜像源之间轻松快速地切换）<br>列出所有源： nrm ls<br>查看当前源：nrm current<br>使用某个源：nrm use &lt;源名称&gt;<br>添加一个源：nrm add &lt;源名称&gt; &lt;源地址&gt;<br>删除一个源：nrm del &lt;源名称&gt;<br>  <a href="https://www.npmjs.com/package/nrm">nrm查看更多指令</a></p></div>
<h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><div class="post-note note-info"><p>pnpm也称高性能npm,相比npm、yarn优势在于节省磁盘空间并提升安装速度。<br>安装依赖：pnpm install xxx&#x2F;pnpm i xxx<br>设置包下载源：pnpm config set registry<br>获取包下载源：pnpm config get registry<br>安装依赖到dependencies:pnpm add<br>安装依赖到devDependencies：pnpm add -D<br>更新依赖包：pnpm update [package]，pnpm up [package]	<br>删除依赖包：pnpm remove [package]<br>所有命令查询文档：<a href="https://www.pnpm.cn/cli/add">pnpm中文文档-CLI命令</a></p></div>
<h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><div class="post-note note-info"><p>安装指定版本node：nvm install vx.x.x<br>安装最新node：nvm install stable<br>设置node默认版：nvm alias default [node版本号]<br>删除指定版本node：nvm uninstall vx.x.x<br>查看所有已安装版本： nvm ls，nvm list<br>列出所以远程服务器的版本：nvm ls-remote<br>显示当前的版本：nvm current<br>给不同的版本号添加别名：nvm alias<br>删除已定义的别名：nvm unalias<br>在当前版本node下，重新全局安装指定版本号的npm包：nvm reinstall-packages<br>查看当前版本： nvm -v<br><a href="https://nvm.uihtm.com/">nvm官方文档</a></p></div>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><div class="post-note note-info"></div>
<h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><div class="post-note note-info"></div>
]]></content>
      <categories>
        <category>拓展学习</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>基于fabricjs搭建canvas画布</title>
    <url>/posts/2bdb1f55.html</url>
    <content><![CDATA[<h1 id="为什么选择fabricjs"><a href="#为什么选择fabricjs" class="headerlink" title="为什么选择fabricjs"></a>为什么选择fabricjs</h1><p>canvas画布由于本身提供的api使用上并不是很便捷，所以一般在进行canvas画布使用的时候，我们会选用一些三方库。这些三方库对一些常用api进行了聚合和封装改进，更进一步的会在上层在做一些其他的处理，这里面做的比较好的有<a href="http://fabricjs.com/">fabricjs</a>、<a href="https://pixijs.com/">pixi</a>,其中fabricjs相对来说时间更久，类似于jquery在js中的地位</p>
<h1 id="画布需求分析"><a href="#画布需求分析" class="headerlink" title="画布需求分析"></a>画布需求分析</h1><p>我们实现一个画布前，首先得清楚画布需要实现的基本功能。这里我们梳理一下一个画布必须包含的基础能力。</p>
<h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><ol>
<li>无限画布 这应该是先有canvas画布插件统一提供的基础能力</li>
<li>本地上传 本地资源可以上传到画布实现渲染</li>
<li>画布操作<ol>
<li>画布平移</li>
<li>画布缩放(鼠标位置作为中心点)</li>
</ol>
</li>
<li>图片操作<ol>
<li>图片拖动</li>
<li>图片缩放</li>
</ol>
</li>
<li>画笔 画笔的基础参数修改，画笔粗细、颜色</li>
<li>橡皮擦 也是基础配置的修改，橡皮擦的大小</li>
<li>下载画布 如何可以完整的下载整张画布上的所有资源，包括不在屏幕内但处于画布上的元素</li>
</ol>
<h1 id="搭建画布"><a href="#搭建画布" class="headerlink" title="搭建画布"></a>搭建画布</h1><h2 id="fabric创建画布"><a href="#fabric创建画布" class="headerlink" title="fabric创建画布"></a>fabric创建画布</h2><p>fabric创建画布其实很简单，接下来我们就通过fabric先来创建一个画布</p>
<pre class="highlight"><code class="hljs bash">&lt;script src=<span class="hljs-string">&quot;/src/assets/js/fabric.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;canvas <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;&lt;/canvas&gt;<br></code></pre>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">new</span> fabric.<span class="hljs-title class_">Canvas</span>(<span class="hljs-string">&#x27;c&#x27;</span>, &#123;&#125;)<br></code></pre>
<p>首先引入fabricjs，在html中创建一个canvas标签用来作为我们的目标画布。接下来要通过fabric创建一个画布，我们只需要new一个fabric.Canvas对象就可以了 此处可以有一些参数，常见的比如width、height</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">new</span> fabric.<span class="hljs-title class_">Canvas</span>(<span class="hljs-string">&#x27;c&#x27;</span>, &#123;    <span class="hljs-attr">width</span>: <span class="hljs-string">&#x27;800px&#x27;</span>,    <span class="hljs-attr">height</span>: <span class="hljs-string">&#x27;500px&#x27;</span>&#125;)<br></code></pre>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>为了方便后面维护以及调用，我们在此处可以针对需求的画布进行对象封装,然后在对外暴露出画布操作需要的api</p>
<h2 id="Stage类"><a href="#Stage类" class="headerlink" title="Stage类"></a>Stage类</h2><p>提供基础的Stage类作为我们的画布对象, 在new 时调用我们上面new fabric.Canvas(‘c’, {})方法来创建一个画布<br>通过 innerWidth&#96;&#96;innerHeight将画布的大小设置为全屏</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stage</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">el</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span> = el;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">init</span>();<br>    &#125;<br>    <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;缺少el元素&quot;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span> = <span class="hljs-keyword">new</span> fabric.<span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>, &#123;<br>            <span class="hljs-attr">width</span>: innerWidth,<br>            <span class="hljs-attr">height</span>: innerHeight,<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre>
<p>此时我们再创建一个画布，通过以下方式</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Stage</span>(c)<br></code></pre>
<h2 id="基本的页面布局"><a href="#基本的页面布局" class="headerlink" title="基本的页面布局"></a>基本的页面布局</h2><p>画布的功能比如上传、画笔、橡皮擦等都需要页面上有固定的按钮来触发，所以我们的页面需要有一个简单的布局，也就是需要一个toolbar来安置这些按钮。<br>so我们写一个简单的toolbar组件放在我们画布的顶部<br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1681976593357-7f852260-dcbb-41d8-b762-24764a04af4f.png#averageHue=%23efefee&clientId=uaa2f216b-c007-4&from=paste&id=u18e5faf8&originHeight=1300&originWidth=2440&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u2a53defd-79e0-43fe-b810-bf5a477e5a8&title=" class="lozad post-image"src="https://cdn.nlark.com/yuque/0/2023/png/28427234/1681976593357-7f852260-dcbb-41d8-b762-24764a04af4f.png#averageHue=%23efefee&clientId=uaa2f216b-c007-4&from=paste&id=u18e5faf8&originHeight=1300&originWidth=2440&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u2a53defd-79e0-43fe-b810-bf5a477e5a8&title="></p>
<p>前面我们已经创建了一个画布，接下来我们来实现画布里面的具体功能。</p>
<h1 id="本地上传"><a href="#本地上传" class="headerlink" title="本地上传"></a>本地上传</h1><p>我们来分析本地上传的功能，不考虑后端存储，其实本地上传就本地应用来说主要分为两部分，以图片为例：</p>
<ol>
<li>本地图片上传</li>
<li>画布渲染上传的图片</li>
</ol>
<h2 id="本地图片上传"><a href="#本地图片上传" class="headerlink" title="本地图片上传"></a>本地图片上传</h2><p>首先我们来实现本地图片上传，此处可以直接使用element-ui的el-upload组件来实现本地文件的上传,只需在原有上传的时候进行拦截获取就行</p>
<pre class="highlight"><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-upload</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-model:file-list</span>=<span class="hljs-string">&quot;fileList&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;upload-demo&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">multiple</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:limit</span>=<span class="hljs-string">&quot;100&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:before-upload</span>=<span class="hljs-string">&quot;handleUpload&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:show-file-list</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">  &gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>本地上传<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-upload</span>&gt;</span><br></code></pre>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 上传时触发回调</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; rawFile file对象的上传数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125; 是否终止后续操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleUpload</span> = (<span class="hljs-params">rawFile</span>) =&gt; &#123;<br>  <span class="hljs-comment">// 此处暂时不用关注，重点是获取到上传的图片数据</span><br>  stage.<span class="hljs-title function_">addImg</span>(file);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre>
<p>上面我们获取到了要上传的图片数据，接下来我们将获取到的图片资源渲染到我们画布上</p>
<h2 id="画布渲染上传的图片"><a href="#画布渲染上传的图片" class="headerlink" title="画布渲染上传的图片"></a>画布渲染上传的图片</h2><p>fabricjs中我们要把画布渲染到画布上有两种方法：</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 同步加载</span><br>fabric.<span class="hljs-property">Image</span><br></code></pre>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 异步加载</span><br>fabric.<span class="hljs-property">Image</span>.<span class="hljs-property">fromURL</span><br></code></pre>
<p>介于我们目前已经拿到本地上传的file文件，同时本地环境下因为没有后端存储又受浏览器限制获取不到本地文件有效的url地址，所以此处加载图片我们选择同步加载<br>另一方面因为我们此时拿到的是file文件，所以我们首先需要做的是怎么把file文件转换为image对象<br>image对象很好获取，new Image()然后加载一下对应的图片就可以获取到，但image对象怎么加载file文件呢？<br>此处我们需要了解一个api <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader">FileReader</a>对象, 使用FileReader我们可以读取file文件</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 画布添加元素，渲染图片</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; file 待上传的file数据</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">addImg</span>(<span class="hljs-params">file</span>) &#123;<br>    <span class="hljs-comment">// 读取图片数据</span><br>    <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br>    reader.<span class="hljs-title function_">readAsDataURL</span>(file);<br>    reader.<span class="hljs-property">onloadend</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> imgobj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>      imgobj.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// 画布加载、渲染</span><br>        fabric.<span class="hljs-property">Image</span>.<span class="hljs-title function_">fromObject</span>(imgobj, <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">// 调用前面创建画布存储的canvas对象加载image</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">add</span>(obj);<br>        &#125;);<br>      &#125;;<br>      imgobj.<span class="hljs-property">src</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>;<br>    &#125;;<br>  &#125;<br></code></pre>


<h1 id="画布基础操作"><a href="#画布基础操作" class="headerlink" title="画布基础操作"></a>画布基础操作</h1><h2 id="画布平移"><a href="#画布平移" class="headerlink" title="画布平移"></a>画布平移</h2><p>fabricjs没有自带的画布平移功能，那我们如何实现呢？首先我们先来整理需求。<br>正常的平移就是按住鼠标拖动画布但需要注意的是如果画布上存在其他元素，比如我们前面上传的图片，鼠标如果按下时刚好处于这些元素上面我们是否需要依旧进行平移操作？如果这个时候我们需要做一些其他操作呢？换句话说就是鼠标处于画布空白位置时正常进行平移， 但如果处于元素上时则不进行平移操作。<br>接下来我们来监听鼠标的相关事件：mouse:down<code>mouse:move</code>mouse:up,来实现一个基础的元素拖动功能</p>
<pre class="highlight"><code class="hljs javascript">canvas.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;mouse:down&quot;</span>, <span class="hljs-function">(<span class="hljs-params">opt</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 鼠标按下时触发</span><br>  <span class="hljs-keyword">if</span> (!opt.<span class="hljs-property">target</span>) &#123;<br>    <span class="hljs-keyword">let</span> evt = opt.<span class="hljs-property">e</span>;<br>    canvas.<span class="hljs-property">isDragging</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// isDragging 是自定义的，开启移动状态</span><br>    canvas.<span class="hljs-property">lastPosX</span> = evt.<span class="hljs-property">clientX</span>; <span class="hljs-comment">// lastPosX 是自定义的</span><br>    canvas.<span class="hljs-property">lastPosY</span> = evt.<span class="hljs-property">clientY</span>; <span class="hljs-comment">// lastPosY 是自定义的</span><br>  &#125;<br>&#125;);<br><br>canvas.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;mouse:move&quot;</span>, <span class="hljs-function">(<span class="hljs-params">opt</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 鼠标移动时触发</span><br>  <span class="hljs-keyword">if</span> (canvas.<span class="hljs-property">isDragging</span>) &#123;<br>    <span class="hljs-keyword">let</span> evt = opt.<span class="hljs-property">e</span>;<br>    <span class="hljs-keyword">let</span> vpt = canvas.<span class="hljs-property">viewportTransform</span>; <span class="hljs-comment">// 聚焦视图的转换</span><br>    vpt[<span class="hljs-number">4</span>] += evt.<span class="hljs-property">clientX</span> - canvas.<span class="hljs-property">lastPosX</span>;<br>    vpt[<span class="hljs-number">5</span>] += evt.<span class="hljs-property">clientY</span> - canvas.<span class="hljs-property">lastPosY</span>;<br>    canvas.<span class="hljs-title function_">requestRenderAll</span>(); <span class="hljs-comment">// 重新渲染</span><br>    canvas.<span class="hljs-property">lastPosX</span> = evt.<span class="hljs-property">clientX</span>;<br>    canvas.<span class="hljs-property">lastPosY</span> = evt.<span class="hljs-property">clientY</span>;<br>  &#125;<br>&#125;);<br><br>canvas.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;mouse:up&quot;</span>, <span class="hljs-function">(<span class="hljs-params">opt</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 鼠标松开时触发</span><br>  canvas.<span class="hljs-title function_">setViewportTransform</span>(canvas.<span class="hljs-property">viewportTransform</span>); <span class="hljs-comment">// 设置此画布实例的视口转换</span><br>  canvas.<span class="hljs-property">isDragging</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 关闭移动状态</span><br>&#125;);<br><br></code></pre>
<h2 id="画布缩放"><a href="#画布缩放" class="headerlink" title="画布缩放"></a>画布缩放</h2><p>缩放fabricjs本身提供了API来实现这个功能，但默认的功能不符合我们的操作习惯。首先他的缩放是以画布左上角为缩放点进行的缩放，同时也不能跟进鼠标的位置自动进行中心点切换。所以我们来进行一下改造。还是先是先梳理一下我们的需求：</p>
<ol>
<li>缩放比例展示在工具栏。同时可以在工具栏手动输入更改</li>
<li>缩放默认以画布中心点作为缩放中心点</li>
<li>鼠标如果在画布上，缩放就以鼠标的位置作为中心点进行缩放</li>
</ol>
<h3 id="输入缩放"><a href="#输入缩放" class="headerlink" title="输入缩放"></a>输入缩放</h3><p>输入框我们简单使用input的绑定来获取值</p>
<pre class="highlight"><code class="hljs javascript">&lt;input type=<span class="hljs-string">&quot;range&quot;</span> :min=<span class="hljs-string">&quot;zoom.min * 100&quot;</span> :max=<span class="hljs-string">&quot;zoom.max * 100&quot;</span> v-model=<span class="hljs-string">&quot;zoomVal&quot;</span>/&gt;<br></code></pre>
<p>拿到zoomVal之后我们需要把值实时更新到canvas画布中,fabricjs中canvas对象提供了setZoom方法用来设置缩放比例</p>
<pre class="highlight"><code class="hljs javascript">stage.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">setZoom</span>(<span class="hljs-title class_">Number</span>(zoomVal) / <span class="hljs-number">100</span>);<br></code></pre>
<p>调用后我们发现，画布确实缩放了，但缩放的中心点却是画布的左上角， 这与我们的预期不符, 此时我们希望的默认是以画布中心点进行缩放。<br>查询发现canvas还有一个相关的apizoomToPoint,我们可以通过设置坐标来达到预期的效果。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleZoomChange</span> = (<span class="hljs-params">val</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    zoom.<span class="hljs-property">value</span>.<span class="hljs-property">val</span> = <span class="hljs-title class_">Number</span>(val.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// stage.canvas.setZoom(Number(val) / 100); // 左上角为中心点</span><br>    stage.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">zoomToPoint</span>(<br>      &#123;<br>        <span class="hljs-attr">x</span>: innerWidth / <span class="hljs-number">2</span>,<br>        <span class="hljs-attr">y</span>: innerHeight / <span class="hljs-number">2</span>,<br>      &#125;,<br>      zoom.<span class="hljs-property">value</span>.<span class="hljs-property">val</span><br>    ); <span class="hljs-comment">// 画布中心为中心点</span><br>  &#125;<br>&#125;;<br></code></pre>
<p>这就实现了画布随着我们输入框输入值变化而变化。接下来我们如何实现在画布上进行缩放呢？同时还需要保持输入框展示的值跟随画布缩放而变化</p>
<h3 id="画布缩放-1"><a href="#画布缩放-1" class="headerlink" title="画布缩放"></a>画布缩放</h3><p>要实现画布上的缩放， 我们首先需要监听鼠标的滚轮变化情况，为canvas绑定wheel事件- mouse:wheel。事件返回opt会包含fabric提供的一些数据，包括鼠标event数据</p>
<pre class="highlight"><code class="hljs javascript">canvas.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;mouse:wheel&quot;</span>, <span class="hljs-function">(<span class="hljs-params">opt</span>) =&gt;</span> &#123;&#125;)<br></code></pre>
<p>通过event我们可以获取到鼠标的位置信息，基于上面提到的canvas.zoomToPoint来设置缩放。基本流程如下</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">let</span> zoom = canvas.<span class="hljs-title function_">getZoom</span>(); <span class="hljs-comment">// 获取画布当前缩放值</span><br><span class="hljs-comment">// 控制缩放范围在 0.01~20 的区间内</span><br>zoom *= <span class="hljs-number">0.999</span> ** delta;<br><span class="hljs-keyword">if</span> (zoom &gt; max) zoom = max;<br><span class="hljs-keyword">if</span> (zoom &lt; min) zoom = min;<br><span class="hljs-comment">// 设置画布缩放比例</span><br><span class="hljs-comment">// 参数1：将画布的所放点设置成鼠标当前位置</span><br><span class="hljs-comment">// 参数2：传入缩放值</span><br>canvas.<span class="hljs-title function_">zoomToPoint</span>(<br>  &#123;<br>    <span class="hljs-attr">x</span>: opt.<span class="hljs-property">e</span>.<span class="hljs-property">offsetX</span>, <span class="hljs-comment">// 鼠标x轴坐标</span><br>    <span class="hljs-attr">y</span>: opt.<span class="hljs-property">e</span>.<span class="hljs-property">offsetY</span>, <span class="hljs-comment">// 鼠标y轴坐标</span><br>  &#125;,<br>  zoom <span class="hljs-comment">// 最后要缩放的值</span><br>);<br><br></code></pre>
<p>这就实现了鼠标在画布上的缩放， 我们只需要把此处的zoom赋值给input的zoomVal就可以直接实现数据的双向展示。</p>
<h1 id="图片基础操作"><a href="#图片基础操作" class="headerlink" title="图片基础操作"></a>图片基础操作</h1><p>前面我们在画布中上传了图片, 作为一个工具我们需要能够对上传的元素进行一些基本的操作，比如针对图片进行缩放、拖动、旋转、框选、合并图层、解散图层等。<br>fabric对元素的拖动、旋转以及框选本身提供了相关功能，这里我们就不做说明了。 接下来我们依次来实现图片的缩放、框选、合并图层、解散图层。</p>
<h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>前面画布缩放的时候我们针对canvas的mouse:wheel进行了监听，并在里面实现了画布的缩放。这里我们依旧在该监听内来实现元素的缩放。 前面介绍了canvas事件会在回调里返回event对象，所以我们基于event.target（这里和dom是一样的）来判断鼠标下是否有元素</p>
<pre class="highlight"><code class="hljs javascript">canvas.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;mouse:wheel&quot;</span>, <span class="hljs-function">(<span class="hljs-params">opt</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; target &#125; = opt;<br>    <span class="hljs-keyword">let</span> delta = opt.<span class="hljs-property">e</span>.<span class="hljs-property">deltaY</span>; <span class="hljs-comment">// 滚轮向上滚一下是 -100，向下滚一下是 100</span><br>    <span class="hljs-keyword">if</span> (target &amp;&amp; target.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;image&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 获取缩放前的信息数据</span><br>        <span class="hljs-keyword">const</span> height = target.<span class="hljs-title function_">getScaledHeight</span>();<br>        <span class="hljs-keyword">const</span> width = target.<span class="hljs-title function_">getScaledWidth</span>();<br>        <span class="hljs-keyword">const</span> zoomVal = target.<span class="hljs-title function_">getTotalObjectScaling</span>();<br>        <span class="hljs-keyword">const</span> &#123; scaleX, scaleY &#125; = zoomVal;<br>        <span class="hljs-keyword">let</span> X = <span class="hljs-number">0.9999</span> ** delta;<br>        <span class="hljs-keyword">if</span> (X &gt; max) X = max;<br>        <span class="hljs-keyword">if</span> (X &lt; min) X = min;<br>        <span class="hljs-keyword">const</span> Y = X;<br>        <span class="hljs-comment">// 设置缩放大小</span><br>        target.<span class="hljs-title function_">scaleToWidth</span>(width * X, <span class="hljs-literal">true</span>);<br>        target.<span class="hljs-title function_">scaleToHeight</span>(height * Y, <span class="hljs-literal">true</span>);<br>        canvas.<span class="hljs-title function_">requestRenderAll</span>();<br>    &#125;<br>&#125;)<br><br></code></pre>
<p>元素的缩放与画布不同，需要分别针对元素的width、height进行缩放设置。同时调用canvas.requestRenderAll();来刷新画布元素</p>
<h2 id="合并-x2F-解散图层"><a href="#合并-x2F-解散图层" class="headerlink" title="合并&#x2F;解散图层"></a>合并&#x2F;解散图层</h2><p>图层合并的功能我们基于分组来实现， 这块都有相关的api,唯一需要注意的是新分组创建是通过对元素的拷贝来创建分组内的元素，原有的元素需要手动删除</p>
<h4 id="合并图层实现"><a href="#合并图层实现" class="headerlink" title="合并图层实现"></a>合并图层实现</h4><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   *新建分组</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; canvas 当前画布对象</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; opts 组配置参数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Object</span>&#125; 返回的group对象</span><br><span class="hljs-comment">   */</span><br><span class="hljs-title function_">create</span>(<span class="hljs-params">canvas, opts</span>) &#123;<br>    <span class="hljs-comment">// 判断当前有没有选中元素，如果没有就不执行任何操作</span><br>    <span class="hljs-keyword">if</span> (!canvas.<span class="hljs-title function_">getActiveObject</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> activeObject = canvas.<span class="hljs-title function_">getActiveObject</span>();<br>    <span class="hljs-keyword">const</span> &#123; top, left &#125; = activeObject;<br>    <span class="hljs-keyword">const</span> group = <span class="hljs-keyword">new</span> fabric.<span class="hljs-title class_">Group</span>(activeObject.<span class="hljs-property">_objects</span>, &#123;<br>        top,<br>        left,<br>    &#125;);<br>    activeObject.<span class="hljs-property">_objects</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;<br>        canvas.<span class="hljs-title function_">remove</span>(element);<br>    &#125;);<br>    canvas.<span class="hljs-title function_">add</span>(group);<br>    canvas.<span class="hljs-title function_">requestRenderAll</span>();<br>    <span class="hljs-keyword">return</span> group;<br>&#125;<br><br></code></pre>
<h4 id="解散图层实现"><a href="#解散图层实现" class="headerlink" title="解散图层实现"></a>解散图层实现</h4><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 解散分组</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; canvas 画布对象</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Object</span>&#125; 返回的group对象</span><br><span class="hljs-comment">   */</span><br><span class="hljs-title function_">dispersed</span>(<span class="hljs-params">canvas</span>) &#123;<br>    <span class="hljs-comment">// 判断当前有没有选中元素，如果没有就不执行任何操作</span><br>    <span class="hljs-keyword">if</span> (!canvas.<span class="hljs-title function_">getActiveObject</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断当前是否选中组，如果不是，就不执行任何操作， 此处需要考虑多选</span><br>    <span class="hljs-keyword">if</span> (canvas.<span class="hljs-title function_">getActiveObject</span>().<span class="hljs-property">type</span> !== <span class="hljs-string">&quot;group&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 先获取当前选中的对象，然后打散</span><br>    canvas.<span class="hljs-title function_">getActiveObject</span>().<span class="hljs-title function_">toActiveSelection</span>();<br>&#125;<br><br></code></pre>
<h1 id="画笔"><a href="#画笔" class="headerlink" title="画笔"></a>画笔</h1><p>fabric提供了Brush类， 这里我们使用PencilBrush来实现简单的画笔功能，主要包括画笔颜色更改、笔尖大小更改。<br>方便复用我们创建一个Brush 类来实现</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Brush</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">freeDrawingBrush</span> = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *新建画笔</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; canvas 当前画布对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">create</span>(<span class="hljs-params">canvas</span>) &#123;<br>        canvas.<span class="hljs-property">isDrawingMode</span> = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (canvas.<span class="hljs-property">isDrawingMode</span>) &#123;<br>            canvas.<span class="hljs-property">freeDrawingBrush</span> = <span class="hljs-keyword">new</span> fabric.<span class="hljs-title class_">PencilBrush</span>(canvas);<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">freeDrawingBrush</span> = canvas.<span class="hljs-property">freeDrawingBrush</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *设置画笔颜色</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; value 橡皮擦颜色</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">setColor</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">freeDrawingBrush</span>.<span class="hljs-property">color</span> = value;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *设置画笔宽度</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; value 橡皮擦宽度</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">setWidth</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">freeDrawingBrush</span>.<span class="hljs-property">width</span> = <span class="hljs-built_in">parseInt</span>(value, <span class="hljs-number">10</span>) || <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *销毁画笔</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; canvas 当前画布对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">destory</span>(<span class="hljs-params">canvas</span>) &#123;<br>        canvas.<span class="hljs-property">freeDrawingBrush</span> = <span class="hljs-literal">null</span>;<br>        canvas.<span class="hljs-property">isDrawingMode</span> = <span class="hljs-literal">false</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">freeDrawingBrush</span> = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre>
<p>创建消耗时需要把前面创建的canvas对象传进来</p>
<h1 id="橡皮擦"><a href="#橡皮擦" class="headerlink" title="橡皮擦"></a>橡皮擦</h1><p>fabric没有橡皮擦相关的实现。我们先来简单的梳理一下橡皮擦的功能，其实很简单就是鼠标滑过的地方按照轨迹清除相关的元素。反过来实现我们可以进行轨迹背景填充。也就是使用画笔来实现橡皮擦的轨迹填充上canvas的背景色。<br>具体功能实现可以调用上main的Brush类。这里就不在重复实现。</p>
<h1 id="下载画布"><a href="#下载画布" class="headerlink" title="下载画布"></a>下载画布</h1><p>现在我们的画布上已经有了很多元素，各种操作结束后我们如何把编辑的效果下载下来呢？<br>fabric针对canvas提供了toDataURL的API可以以base64格式输出画布数据， 我们基于这个api来实现画布下载的功能<br>在这之前首先我们基于a标签的download来实现一个基础的下载能力，</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 下载功能</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;href&quot;</span>, url);<br>a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;download&quot;</span>, name);<br>a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;target&quot;</span>, <span class="hljs-string">&quot;_blank&quot;</span>);<br>a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;downLoad&quot;</span>);<br>a.<span class="hljs-title function_">click</span>();<br><br></code></pre>

<p>接着我们来调用toDataURL，将返回的base64赋值给a标签的href</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">const</span> baseimg = canvas.<span class="hljs-title function_">toDataURL</span>()<br> <span class="hljs-comment">// 下载功能</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;href&quot;</span>, baseimg);<br>a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;download&quot;</span>, <span class="hljs-string">&#x27;test.jpg&#x27;</span>);<br>a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;target&quot;</span>, <span class="hljs-string">&quot;_blank&quot;</span>);<br>a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;downLoad&quot;</span>);<br>a.<span class="hljs-title function_">click</span>();<br><br></code></pre>
<p>但这个时候我们就会发现下载下来的图片有些不对，那是因为默认下来下来的只是当前屏幕内的， 所以我们需要在toDataURL的时候对画布进行剪切。也就是说我们需要算出画布上所有元素的范围，然后用这个范围对画布进行裁剪，再下载裁剪后的画布。上代码</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 下载画布</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; type 可以下载的图片格式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">outputImg</span> = (<span class="hljs-params">type</span>) =&gt; &#123;<br>    type = type || <span class="hljs-string">&quot;jpeg&quot;</span>;<br>    <span class="hljs-comment">// 通过偏移量、宽高处理全图</span><br>    <span class="hljs-keyword">const</span> all = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAllObject</span>();<br>    <span class="hljs-comment">// 计算画布元素边界</span><br>    <span class="hljs-keyword">const</span> maxleftObj = _.<span class="hljs-title function_">maxBy</span>(all, <span class="hljs-function">(<span class="hljs-params">o</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> o.<span class="hljs-property">left</span>;<br>    &#125;);<br>    <span class="hljs-keyword">const</span> minleftObj = _.<span class="hljs-title function_">minBy</span>(all, <span class="hljs-function">(<span class="hljs-params">o</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> o.<span class="hljs-property">left</span>;<br>    &#125;);<br>    <span class="hljs-keyword">const</span> maxtopObj = _.<span class="hljs-title function_">maxBy</span>(all, <span class="hljs-function">(<span class="hljs-params">o</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> o.<span class="hljs-property">top</span>;<br>    &#125;);<br>    <span class="hljs-keyword">const</span> mintopObj = _.<span class="hljs-title function_">minBy</span>(all, <span class="hljs-function">(<span class="hljs-params">o</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> o.<span class="hljs-property">top</span>;<br>    &#125;);<br>    <span class="hljs-comment">// 剪切画布， 输出画布数据base64格式</span><br>    <span class="hljs-comment">// console.log(111, minleftObj, minleftObj.left, mintopObj, mintopObj.top);</span><br>    <span class="hljs-keyword">const</span> baseimg = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">toDataURL</span>(&#123;<br>        <span class="hljs-attr">format</span>: type,<br>        <span class="hljs-attr">quality</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-comment">// multiplier: this.zoom,</span><br>        <span class="hljs-attr">withoutTransform</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">left</span>: minleftObj.<span class="hljs-title function_">getBoundingRect</span>().<span class="hljs-property">left</span>,<br>        <span class="hljs-attr">top</span>: mintopObj.<span class="hljs-title function_">getBoundingRect</span>().<span class="hljs-property">top</span>,<br>        <span class="hljs-attr">width</span>: (maxleftObj.<span class="hljs-property">left</span> - minleftObj.<span class="hljs-property">left</span> + maxleftObj.<span class="hljs-property">width</span>) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">zoom</span>,<br>        <span class="hljs-attr">height</span>: (maxtopObj.<span class="hljs-property">top</span> - mintopObj.<span class="hljs-property">top</span> + mintopObj.<span class="hljs-property">height</span>) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">zoom</span>,<br>    &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">requestRenderAll</span>();<br>    <span class="hljs-comment">// 下载功能</span><br>    <span class="hljs-keyword">let</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>    a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;href&quot;</span>, baseimg);<br>    a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;download&quot;</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.parse(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>())&#125;</span>.<span class="hljs-subst">$&#123;type&#125;</span>`</span>);<br>    a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;target&quot;</span>, <span class="hljs-string">&quot;_blank&quot;</span>);<br>    a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;downLoad&quot;</span>);<br>    a.<span class="hljs-title function_">click</span>();<br>&#125;<br><br></code></pre>
<p>到这里我们已经实现了一个画布的基础能力，基于这些能力我们就可以做很多事。但这里还有很大的优化空间。比如图片数据量大的时候如何提高canva的渲染能力，虽然fabric内部已经做了离线渲染，但其实我们依旧可以针对元素进行可是区域内外的分批渲染等</p>
]]></content>
      <categories>
        <category>拓展学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>工作随记</title>
    <url>/posts/a6eed33.html</url>
    <content><![CDATA[<h3 id="减少嵌套-if…else-或-switch-case，简单地使用基本的逻辑运算符AND-x2F-OR。"><a href="#减少嵌套-if…else-或-switch-case，简单地使用基本的逻辑运算符AND-x2F-OR。" class="headerlink" title="减少嵌套 if…else 或 switch case，简单地使用基本的逻辑运算符AND&#x2F;OR。"></a>减少嵌套 if…else 或 switch case，简单地使用基本的逻辑运算符AND&#x2F;OR。</h3><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 与 if (foo == 10) then console.log(&#x27;进入判断了&#x27;) 相同 // 输出: 进入判断了 </span><br><span class="hljs-keyword">let</span> foo = <span class="hljs-number">10</span>; foo === <span class="hljs-number">10</span> &amp;&amp; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;进入判断了&#x27;</span>)  <br><span class="hljs-comment">// 与 if (foo != 5) then console.log(&#x27;进入判断了&#x27;) 相同 // 输出: 进入判断了</span><br>foo === <span class="hljs-number">5</span> || <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;进入判断了&#x27;</span>) <br></code></pre>
<h3 id="Rest（剩余）-amp-Spread-（扩展）运算符-…的两种意义"><a href="#Rest（剩余）-amp-Spread-（扩展）运算符-…的两种意义" class="headerlink" title="Rest（剩余） &amp; Spread （扩展）运算符(…的两种意义)"></a>Rest（剩余） &amp; Spread （扩展）运算符(…的两种意义)</h3><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">//示例1  方法结构传参</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">spread</span>(<span class="hljs-params">arg1, arg2, arg3</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg1);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg2);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg3);<br>&#125;<br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-title function_">spread</span>(...arr);<br><br><span class="hljs-comment">//示例2  合并数组或者对象</span><br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> arr2 = [...arr1, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">var</span> obj2 = &#123; ...obj1, <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">e</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">f</span>: <span class="hljs-number">6</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2);<br></code></pre>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 示例1 当函数参数个数不确定时</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">rest1</span>(<span class="hljs-params">...arr</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>    &#125;<br>&#125;<br><span class="hljs-title function_">rest1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">//示例2 当确定其中几个,后续未知</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">rest2</span>(<span class="hljs-params">item, ...arr</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br>&#125;<br><span class="hljs-title function_">rest2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">//示例3 rest运算符配合 解构使用：</span><br><span class="hljs-keyword">var</span> [a, ...temp] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(temp);<br><br></code></pre>
<h3 id="开发技巧"><a href="#开发技巧" class="headerlink" title="开发技巧"></a>开发技巧</h3><p>尽量在开发中面向接口开发，而不是为了任务去拼凑代码从而将代码开发成了面向实现开发。</p>
<h3 id="自定义边框虚线"><a href="#自定义边框虚线" class="headerlink" title="自定义边框虚线"></a>自定义边框虚线</h3><pre class="highlight"><code class="hljs css">// 一条直的虚线<br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to bottom, <span class="hljs-number">#3A75FF</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#3A75FF</span> <span class="hljs-number">80%</span>, transparent <span class="hljs-number">50%</span>);<br><span class="hljs-attribute">background-size</span>: <span class="hljs-number">3px</span> <span class="hljs-number">18px</span>;<br><span class="hljs-attribute">background-repeat</span>: y-repeat;<br>// 边框虚线<br><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">90deg</span>, <span class="hljs-number">#3A75FF</span> <span class="hljs-number">50%</span>, transparent <span class="hljs-number">0</span>) repeat-x, <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">90deg</span>, <span class="hljs-number">#3A75FF</span> <span class="hljs-number">50%</span>, transparent <span class="hljs-number">0</span>) repeat-x, <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">0deg</span>, <span class="hljs-number">#3A75FF</span> <span class="hljs-number">50%</span>, transparent <span class="hljs-number">0</span>) repeat-y, <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">0deg</span>, <span class="hljs-number">#3A75FF</span> <span class="hljs-number">50%</span>, transparent <span class="hljs-number">0</span>) repeat-y;<br><span class="hljs-attribute">background-size</span>: <span class="hljs-number">8px</span> <span class="hljs-number">2px</span>, <span class="hljs-number">8px</span> <span class="hljs-number">2px</span>, <span class="hljs-number">2px</span> <span class="hljs-number">8px</span>, <span class="hljs-number">2px</span> <span class="hljs-number">8px</span>;<br><span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-number">100%</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">100%</span> <span class="hljs-number">0</span>;<br></code></pre>
<h3 id="项目整体置灰"><a href="#项目整体置灰" class="headerlink" title="项目整体置灰"></a>项目整体置灰</h3><p>为应对各种哀悼日将项目整体置灰</p>
<pre class="highlight"><code class="hljs css"><span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">html</span>&#123;<br>  <span class="hljs-attribute">filter</span>: progid:DXImageTransform.Microsoft.<span class="hljs-built_in">BasicImage</span>(graysale=<span class="hljs-number">1</span>); //针对IE浏览器 <br>  -webkit-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>&#125;<br></code></pre>
<h3 id="video部分浏览器出现边框问题"><a href="#video部分浏览器出现边框问题" class="headerlink" title="video部分浏览器出现边框问题"></a>video部分浏览器出现边框问题</h3><p>对边框进行设置mask-image</p>
]]></content>
      <categories>
        <category>工作随记</category>
      </categories>
      <tags>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>混合开发介绍</title>
    <url>/posts/cb099fff.html</url>
    <content><![CDATA[<h1 id="传统移动端应用的开发的问题"><a href="#传统移动端应用的开发的问题" class="headerlink" title="传统移动端应用的开发的问题"></a>传统移动端应用的开发的问题</h1><h2 id="原生开发的优势"><a href="#原生开发的优势" class="headerlink" title="原生开发的优势"></a>原生开发的优势</h2><ul>
<li>用户体验感好：基于原生客户端语言开发，能最大化的利用设备的性能，提供最优的产品体验</li>
<li>能力强：可以直接和操作系统交互并调用其API，可以实现几乎全部能在移动设备实现的功能和场景</li>
</ul>
<h2 id="原生开发的劣势"><a href="#原生开发的劣势" class="headerlink" title="原生开发的劣势"></a>原生开发的劣势</h2><ul>
<li>动态性：客户端开发通常是有固定的版本发布计划，而且受限于Apple的APP Store审核规则，版本发布的不确定性还会受到政策影响，Android在国内的渠道众多，每次发版都要反复检查渠道，一旦发现线上问题，需要依赖再发版本，容错成本非常高，这也大大增加了对业务的局限性</li>
<li>开发成本：客户端的开发成本高，然而生态还不如Web丰富，npm社区的几万开源包，就爱生更活跃的开发者社区，导致企业来讲客户端的研发成本高于Web开发</li>
<li>跨端一致性：传统客户端开发一套业务，需要实现Android和IOS两套代码，而且由于Android和IOS的操作系统能力差异，同样的需求往往会用不同的视觉和交互来实现，这也导致业务成本居高不下</li>
</ul>
<h1 id="Hybrid开发"><a href="#Hybrid开发" class="headerlink" title="Hybrid开发"></a>Hybrid开发</h1><h2 id="一、JSBridge-webView"><a href="#一、JSBridge-webView" class="headerlink" title="一、JSBridge + webView"></a>一、JSBridge + webView</h2><p>H5 + 原生的开发形式，是混合开发的主流。使用原生技术搭建APP框架，使用H5动态下发内容。由于H5代码只需要开发一次，就能够同时在Android和iOS两个平台同时运行，减小开发成本。H5部分功能越多成本越小。我们称这种H5 + 原生的开发模式为<strong>混合开发</strong>，采用混合模式开发的APP我们称之为<strong>混合应用</strong>或<strong>Hybrid APP</strong>，如果一个应用的大多数功能都是H5实现的话，这就是一个Web APP。混合开发的技术难点原生和H5之间的交互。一般情况下，而JSBridge就是H5与原生交互的方式。例如微信内部的H5开发<br><strong>问题：性能瓶颈导致用户体验不佳，复杂功能难以实现</strong><br><strong>性能差：除了H5与原生不搭配，H5本身就会出现先要在服务器上下载模板、加载资源，资源加载完毕后JS执行阶段才会发起请求获取数据进行渲染、JS的单线程 、交互体验需要专门处理， 调用原生能力复杂，需要客户端进行桥接，提前封装并规定好对接协议，提供给H5、大量重排会容易产生卡顿和掉帧</strong><br><strong>优化：</strong></p>
<h2 id="二、JS-原生UI"><a href="#二、JS-原生UI" class="headerlink" title="二、JS + 原生UI"></a>二、JS + 原生UI</h2><p>JavaScript开发 + 原生渲染的开发方式目前特指Facebook开源的React Native以及阿里开源的Weex。其核心技术点就是：把DOM树映射成原生的控件树。框架会把DOM树自动转化为不同平台的控件树，其最终还是调用原生API来绘制，JS还是和webView一样，再打开APP时会拉去bingdomjs</p>
<h3 id="混合开发的优点"><a href="#混合开发的优点" class="headerlink" title="混合开发的优点"></a>混合开发的优点</h3><ul>
<li>社区庞大，开发成本低</li>
<li>使用前端技术框架，原生渲染，性能可以接受</li>
<li>支持热更新；（目前iOS端有风险，热更新应用禁止上架到APP Store）</li>
</ul>
<p><strong>性能能：打开APP会异步去请求jsbundle，获取到jsbundle后使用JavaScript引擎解析它，渲染成对应平台的原生控件树，与原生通信频率增加性能缺陷越明显</strong><br><strong>优化：预请求或缓存jsbundle，减少资源请求，节流防抖出发通信</strong></p>
<h3 id="混合开发的缺点"><a href="#混合开发的缺点" class="headerlink" title="混合开发的缺点"></a>混合开发的缺点</h3><ul>
<li>因为要和原生通信，难以胜任复杂的绘制与动画工作</li>
<li>js为脚本语言，解释执行，性能和原生开发编译后运行，有一定差距</li>
<li>调用系统硬件功能非常麻烦，频繁渲染造成频繁通信导致性能缺陷，</li>
</ul>
<h2 id="三、自绘引擎"><a href="#三、自绘引擎" class="headerlink" title="三、自绘引擎"></a>三、自绘引擎</h2><p>不依赖操作系统提供的布局、原生组件能力，直接调用GPU或者地城抽象层进行绘制的渲染引擎。</p>
<h3 id="QtMobile"><a href="#QtMobile" class="headerlink" title="QtMobile"></a>QtMobile</h3><p>基于c++，最终表现不佳</p>
<h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><p>2018年Flutter诞生，通过Dart语言构建一套跨平台的开发组件，所有组件基于Skia引擎自绘，在性能上和Native平台的View相媲美，同时解决了上一代框架难以解决的双端一致性等问题，引起大家广泛关注，充分验证了通过绘制构建组件做到Native View 媲美的UI渲染引擎的可行性<br>Flutter是Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过Dart语言开发APP，一套代码同事运行在iOS和Android平台，Flutter提供了丰富的组件、接口，开发者可以很快的为Flutter添加Native扩展。<br>**跨平台自绘引擎skia  **<br><strong>dart语言</strong><br><strong>高性能</strong><br><strong>AOT（提前编译）</strong><br><strong>JIT（即时编译）</strong><br>支持Android iOS 车载 手表</p>
]]></content>
      <categories>
        <category>拓展学习</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>自动创建html</title>
    <url>/posts/fd390730.html</url>
    <content><![CDATA[<p>直接上代码.这里主要是展示一种思想,将功能近乎相同的小页面抽离为一种配置即可完成的东西,防止自己做无用代码</p>
<pre class="highlight"><code class="hljs JavaScript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> outFileBasePath = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;../static&#x27;</span>);<br><span class="hljs-keyword">const</span> dirCache = &#123;&#125;;<br><span class="hljs-keyword">let</span> pageRouter = [<br>    &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">fileName</span>: <span class="hljs-string">&#x27;/introduce/payroll_calculate_incomeTax&#x27;</span>, <span class="hljs-comment">// 路径</span><br>        <span class="hljs-attr">style</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">script</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">750</span>,<br>        <span class="hljs-attr">imgList</span>: [<br>            &#123;<br>                <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;xxxxxx.png&#x27;</span>,<br>                <span class="hljs-attr">alt</span>: <span class="hljs-string">&#x27;产品介绍图&#x27;</span>,<br>            &#125;<br>        ]<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;邀请企业，赚大额现金&#x27;</span>,<br>        <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">fileName</span>: <span class="hljs-string">&#x27;/invitationFriend&#x27;</span>, <span class="hljs-comment">// 路径</span><br>        <span class="hljs-attr">style</span>: <span class="hljs-string">`</span><br><span class="hljs-string">&lt;style&gt;</span><br><span class="hljs-string">    .content &#123;</span><br><span class="hljs-string">        background: #FF4A44;</span><br><span class="hljs-string">        padding-bottom: 67px;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&lt;/style&gt;</span><br><span class="hljs-string">        `</span>,<br>        <span class="hljs-attr">script</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">500</span>,<br>        <span class="hljs-attr">imgList</span>: [<br>            &#123;<br>                <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;xxxxxxxx.png&#x27;</span>,<br>                <span class="hljs-attr">alt</span>: <span class="hljs-string">&#x27;邀请企业福利介绍&#x27;</span>,<br>            &#125;<br>        ]<br>    &#125;<br>];<br>pageRouter.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">router</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> filePath = outFileBasePath + router.<span class="hljs-property">fileName</span>;<br>    <span class="hljs-keyword">let</span> fileContent = <span class="hljs-string">`&lt;!DOCTYPE html&gt;</span><br><span class="hljs-string">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;head&gt;</span><br><span class="hljs-string">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="hljs-string">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="hljs-string">&lt;link rel=&quot;icon&quot; href=&quot;./favicon.ico&quot;&gt;</span><br><span class="hljs-string">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="hljs-string">&lt;title&gt;<span class="hljs-subst">$&#123;router.title || <span class="hljs-string">&#x27;页面标题&#x27;</span>&#125;</span>&lt;/title&gt;</span><br><span class="hljs-string">&lt;style&gt;</span><br><span class="hljs-string">    * &#123;</span><br><span class="hljs-string">        margin: 0;</span><br><span class="hljs-string">        padding: 0;</span><br><span class="hljs-string">        overflow-x: hidden;</span><br><span class="hljs-string">        -ms-overflow-style: none;</span><br><span class="hljs-string">        overflow: -moz-scrollbars-none;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    *::-webkit-scrollbar &#123;</span><br><span class="hljs-string">        display: none;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    .content &#123;</span><br><span class="hljs-string">        width: 100vw;</span><br><span class="hljs-string">        min-height: 100vh;</span><br><span class="hljs-string">        background: #ffffff;</span><br><span class="hljs-string">        display: flex;</span><br><span class="hljs-string">        justify-content: flex-start;</span><br><span class="hljs-string">        flex-direction: column;</span><br><span class="hljs-string">        align-items: center;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    #mask &#123;</span><br><span class="hljs-string">        position: fixed;</span><br><span class="hljs-string">        top: 0;</span><br><span class="hljs-string">        left: 0;</span><br><span class="hljs-string">        right: 0;</span><br><span class="hljs-string">        bottom: 0;</span><br><span class="hljs-string">        z-index: 1;</span><br><span class="hljs-string">        background-color: #ffffff;</span><br><span class="hljs-string">        display: flex;</span><br><span class="hljs-string">        align-items: center;</span><br><span class="hljs-string">        justify-content: center;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    .loading &#123;</span><br><span class="hljs-string">        position: relative;</span><br><span class="hljs-string">        width: 30px;</span><br><span class="hljs-string">        height: 30px;</span><br><span class="hljs-string">        border: 2px solid rgba(0, 0, 0, 0.2);</span><br><span class="hljs-string">        border-left-color: #000;</span><br><span class="hljs-string">        border-radius: 100%;</span><br><span class="hljs-string">        animation: circle infinite 0.75s linear;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    @keyframes circle &#123;</span><br><span class="hljs-string">        0% &#123;</span><br><span class="hljs-string">            transform: rotate(0);</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        100% &#123;</span><br><span class="hljs-string">            transform: rotate(360deg);</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&lt;/style&gt;</span><br><span class="hljs-string"><span class="hljs-subst">$&#123;router.style&#125;</span></span><br><span class="hljs-string">&lt;/head&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="hljs-string">        <span class="hljs-subst">$&#123;router.imgList.map(item =&gt; &#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;img src=&quot;&quot; alt=&quot;<span class="hljs-subst">$&#123;item.alt&#125;</span>&quot;&gt;`</span></span></span><br><span class="hljs-subst"><span class="hljs-string">&#125;).join(<span class="hljs-string">&#x27;&#x27;</span>)&#125;</span></span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    &lt;div id=&quot;mask&quot;&gt;</span><br><span class="hljs-string">        &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    &lt;script&gt;</span><br><span class="hljs-string">        let flag = 0;</span><br><span class="hljs-string">        let imgList = <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(router.imgList)&#125;</span>;</span><br><span class="hljs-string">        let imgs = document.querySelectorAll(&#x27;.content img&#x27;);</span><br><span class="hljs-string">        let mask = document.querySelector(&#x27;#mask&#x27;)</span><br><span class="hljs-string">        imgs.forEach((e, i) =&gt; &#123;</span><br><span class="hljs-string">            let url = imgList[i].url + &#x27;?&#x27; + new Date().getTime();</span><br><span class="hljs-string">            e.src = url;</span><br><span class="hljs-string">            e.onload = function () &#123;</span><br><span class="hljs-string">                flag++;</span><br><span class="hljs-string">                if(flag === <span class="hljs-subst">$&#123;router.imgList.length&#125;</span>)&#123;</span><br><span class="hljs-string">                    handleImgWidth();</span><br><span class="hljs-string">                    window.addEventListener(&quot;resize&quot;, handleImgWidth);</span><br><span class="hljs-string">                    mask.style.display = &#x27;none&#x27;</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;)</span><br><span class="hljs-string">        function handleImgWidth() &#123;</span><br><span class="hljs-string">            let imgArr = document.querySelectorAll(&#x27;.content img&#x27;);</span><br><span class="hljs-string">            let clientWidth = document.querySelector(&#x27;.content&#x27;).clientWidth;</span><br><span class="hljs-string">            if (clientWidth &gt; 750) &#123;</span><br><span class="hljs-string">                for (let i = 0; i &lt; imgArr.length; i++) &#123;</span><br><span class="hljs-string">                    imgArr[i].style.width = &#x27;<span class="hljs-subst">$&#123;router.width&#125;</span>px&#x27;</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">            &#125; else &#123;</span><br><span class="hljs-string">                for (let i = 0; i &lt; imgArr.length; i++) &#123;</span><br><span class="hljs-string">                    imgArr[i].style.width = &#x27;100vw&#x27;</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &lt;/script&gt;</span><br><span class="hljs-string">    <span class="hljs-subst">$&#123;router.script&#125;</span></span><br><span class="hljs-string">&lt;/body&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;/html&gt;</span><br><span class="hljs-string">    `</span><br>    <span class="hljs-title function_">mkdir</span>(filePath + <span class="hljs-string">&#x27;/index.html&#x27;</span>, fileContent)<br>&#125;);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkdir</span>(<span class="hljs-params">filePath, data</span>) &#123;<br>    <span class="hljs-keyword">const</span> arr = filePath.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>);<br>    <span class="hljs-keyword">let</span> dir = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (dir &amp;&amp; !dirCache[dir] &amp;&amp; !fs.<span class="hljs-title function_">existsSync</span>(dir)) &#123;<br>            dirCache[dir] = <span class="hljs-literal">true</span>;<br>            fs.<span class="hljs-title function_">mkdirSync</span>(dir);<br>        &#125;<br>        dir = dir + <span class="hljs-string">&#x27;/&#x27;</span> + arr[i];<br>    &#125;<br>    fs.<span class="hljs-title function_">writeFileSync</span>(filePath, data, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>    &#125;)<br>&#125;<br></code></pre>
<pre class="highlight"><code class="hljs bash">$ <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;node server/statusPage.js &amp;&amp; cross-env BASE_URL=&#x27;https://www.xxxxx.cn&#x27; nuxt build &quot;</span>,<br><br></code></pre>
]]></content>
      <categories>
        <category>工作随记</category>
      </categories>
      <tags>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>前端所遇到的问题</title>
    <url>/posts/3a36e4b1.html</url>
    <content><![CDATA[<p>1.再上传上传时出现，出现再次上传后文件数量与上次相同的情况下不触发onchange方法，检查完成后是否清楚input的value<br>2.iOS的弹性滑动属性-<a href="https://so.csdn.net/so/search?q=webkit&spm=1001.2101.3001.7020">webkit</a>-overflow-scrolling: touch会导致z-index属性失效。可以用transform: translateZ来实现。<br>3.VScode快速下载，进入<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>官网进行下载，然后找到下载文件的下载地址，将<a href="https://az764295.vo.msecnd.net/stable/b06ae3b2d2dbfe28bca3134cc6be65935cdfea6a/VSCode-darwin-universal.zip">https://az764295.vo.msecnd.net/stable/b06ae3b2d2dbfe28bca3134cc6be65935cdfea6a/VSCode-darwin-universal.zip</a>中的az764295.vo.msecnd.net替换成vscode.cdn.azure.cn即可<br>4.对接三方时，对方api没有使用任何设计模式，但是项目中多处根据条件需要加载对应事件，在开发上线时，因为接口返回有快慢，因此开发的需求有时触发有时不触发，在多次检查后发现问题所在，创建了一个发布—订阅模式的类，并可以根据命名空间创建不同的监听，以此解决此类问题。<br>5.<a href="child:page.sync=&quot;page&quot;">child:page.sync=&quot;page&quot;</a></child> .sync 可以将父组件值传递到子组件中，并可以让子组件修改该值而不报错。修改方式为：this.$emit(‘update:page’, ‘子组件修改的值’)<br>6.在使用标签的contenteditable属性时，Safari浏览器需设置use-select:auto，否则会出现选不中的情况</p>
<h4 id="持续更新中…"><a href="#持续更新中…" class="headerlink" title="持续更新中…"></a>持续更新中…</h4>]]></content>
      <categories>
        <category>工作随记</category>
      </categories>
  </entry>
</search>
